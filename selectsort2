#!/bin/bash
# The initial filename ASETOOLS.SH
# An attempt to create something like SAP(R) BR*Tools(R).
VERSION=11-03-2022

# Script parameters:
# nokey - force to ask sapsa's password
# log_monitor /sybase/SID/log - trace log-files 

#################################################################### DEVELOPMENT INFO ####################################################################

#isql-bash-functions for syb<sid>:
#isql_request_columns_bold
#isql_request_columns_nobold
#isql_request_nocolumns_nobold
#isql_request_nocolumns_bold
#isql_request_nocolumns_nobold_verbose
#isql_request_nocolumns_bold "${array00[@]}"

#root:
#isql_request_nocolumns_verbose_root

# test tables: /IWBEP/I_SBD_SE, SXMSAGGERRMAP, TCUSTYPTXT, HRS1205, CRMC_BSP_EVENT_T, DB2JOB, E070, W3BHTMPART, RSRRENDERERATR, /BOBF/CONF_UI_ET      

# new style: isql_request_nocolumns_bold "${array00[@]}"


RED=$(tput setaf 1)
GREEN=$(tput setaf 2)         
YELLOW=$(tput setaf 3)
BLUE=$(tput setaf 4)
MAGENDA=$(tput setaf 5)
CYAN=$(tput setaf 6)
RESTORE=$(tput sgr0)
BOLD=$(tput bold)



#################################################################### FUNCTIONS ####################################################################
print_info(){
clear
echo "${BOLD}ASETOOLS v.1.1 $VERSION${RESTORE}"
echo "Menue description: ${BOLD}K:\Dokumentation\SAP\Datenbank\SAPASE\ASETOOLS\ASETOOLS_Menu.xlsx${RESTORE} | ASE-Profi-Team: "
echo "Operational guide: ${BOLD}K:\Dokumentation\SAP\Datenbank\SAPASE\ASETOOLS\ASETOOLS_Guide.pdf${RESTORE} | Developer: "
echo
echo "INFO: The session log-file: $LOG_FILE"; echo "TAG = $tdsuser" > "$LOG_FILE"
chown "$sybase_user":sapsys "$LOG_FILE"
}

print_exit(){
while true; do read -p "Do you really want to cancel ASETOOLS? Enter [y]es/[n]o: " yn
        case "$yn" in y) echo "This session has been saved in $LOG_FILE"; echo "Bye-bye!"; exit 0;;
                      n) break;; esac; done; set_page
}

tail_rows(){
echo "${BOLD}INFO:${RESTORE} Last ${1} entries from ${alert_log}:"
tail -${1} "$alert_log"
}

pause(){
echo "${RESTORE}"
read -p "Press [Enter] to continue. . ."
echo
}

bold_text(){
echo "${BOLD}"
}

nobold_text(){
echo "${RESTORE}"
}

unset_temp_vars(){
nobold_text
unset count string string1 string2 yn choice answer answr accept accept2 go index
unset string0{0..9} string{10..100} par0{0..9} par{10..100} par0{0..9}n par{10..100}n db tag disk_init_par0{0..9} disk_init_par{10..100} arr_tables_isql bcp_import cloneArray array00
unset par21
unset data_dev data_dev_size data_dev_file db_dev_file_size
unset DB_LIST
}

server_version(){
ppar00=$(isql -v | grep SQL)
ppar01=$(echo $ppar00 | awk '{ print $3 }' | sed 's|.*/||')
ppar02=$(echo $ppar00 | awk '{ print $4 }')
ppar03=$(echo $ppar00 |awk '{ print $5 }' | cut -f1 -d"/")
ase_version="Sybase ASE ${CYAN}$SYBASE_SID $ppar01 $ppar02 $ppar03${RESTORE}"
}

server_version_root(){
ppar00=$(su ${sybase_user} -c 'isql -v | grep SQL')
ppar01=$(echo $ppar00 | awk '{ print $3 }' | sed 's|.*/||')
ppar02=$(echo $ppar00 | awk '{ print $4 }')
ppar03=$(echo $ppar00 |awk '{ print $5 }' | cut -f1 -d"/")
ase_version="Sybase ASE ${CYAN}$SYBASE_SID $ppar01 $ppar02 $ppar03${RESTORE}"
}

#function join { local IFS="$1"; shift; echo "$*"; }
join(){ 
local IFS="$1"; shift; echo "$*"; 
}

get_flags_runfile(){
flags_from_runfile=(); flags_from_runfile_clean=()
while IFS= read -r line; do flags_from_runfile+=( "$line" )
done < <( grep "\-T" "$run_file" )
for e in "${flags_from_runfile[@]}"; do line=${e:2}; line=${line%?}; flags_from_runfile_clean+=( "$line" ); done
join , ${flags_from_runfile_clean[@]}
#flags_infile=$(get_flags_runfile)
#if [ ${#flags_from_runfile_clean[@]} -eq 0 ]; then flags_infile="*NONE*"; fi
}

get_flags_session(){
flags_from_session=()
flags_from_session_clean=()
for e in "${arr_traceflags_numbers[@]}"; do flags_from_session_clean+=( "$e" ); done
join , ${flags_from_session_clean[@]}
#flags_insession=$(get_flags_session);
#if [ ${#flags_from_session_clean[@]} -eq 0 ]; then flags_insession="*NONE*"; fi
}

get_sap_schema(){
SAP_SCHEMA=$(getOwner); SAP_SCHEMA="${SAP_SCHEMA//[[:blank:]]/}"; SAP_SCHEMA_COL="${CYAN}${SAP_SCHEMA//[[:blank:]]/}${RESTORE}"
}

getOwner(){
isql_session_getOwner <<EOF
SET NOCOUNT ON
SET PROC_RETURN_STATUS OFF
select name from sysusers where name like 'SAPSR3%'
go
EOF
}

get_dbpage_size_sql(){
isql_request_nocolumns_nobold "select @@maxpagesize"
}

get_dbpage_size(){
if [ "$check_ase" == "1" ]; then DB_PAGE_SIZE=$(get_dbpage_size_sql); 
                                 DB_PAGE_SIZE=${DB_PAGE_SIZE//[[:blank:]]/}; 
                                 DB_PAGE_SIZE_KB=$(expr $DB_PAGE_SIZE / 1024)
                                 DB_PAGE_SIZE_KB="${DB_PAGE_SIZE_KB}KB"
                            else DB_PAGE_SIZE_KB="-"; fi
} 

ask_proceed_yn(){
while true; do echo; read -p "${BOLD}Proceed?${RESTORE} (y/n): " yn
        case "$yn" in
                    y) echo; break;;
                    n) set_page;; esac; done; 
}

set_page(){
"$setpage"
}

compare_numbers(){
# number 1 = calculated number
# number 2 = pattern
if [ "$1" -gt "$2" ]; then go=0; echo "$3";
elif [ "$1" -eq "$2" ]; then go=2;
elif [ "$2" -gt "$1" ]; then go=1; fi
}	

read_alert_log(){
echo; read -p "How many last rows to display from $alert_log? " par01
tail -$par01 "$alert_log"
set_page
}

read_alert_log_bkp(){
echo; read -p "How many last rows to read from the $alert_log_bkp? " par01
tail -$par01 "$alert_log_bkp"
set_page
}

read_jsagent_log(){
echo; read -p "How many last rows to read from the $jsagent_log? " par01
tail -$par01 "$jsagent_log"
set_page
}

top_info(){
check_java
check_abap
check_ase
get_dbpage_size
flags_infile=$(get_flags_runfile);
flags_insession=$(get_flags_session);
if [ -z $(get_flags_runfile) ]; then flags_infile="-"; fi
if [ -z $(get_flags_session) ]; then flags_insession="-"; fi
free_mem_ram_show=$(free_mem_ram)
free_mem_swap_show=$(free_mem_swap)
echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S') | $ase_version | $check_ase_text/$check_dbase_text | $sap_abap_status_text | SAP DB-Schema: $SAP_SCHEMA_COL | DB-User: ${CYAN}$DB_USER${RESTORE}"
if [ "$free_mem_ram_show" -gt 9999 ]; then free_mem_ram_show=$(( free_mem_ram_show / 1024)); free_mem_ram_show="${BOLD}${free_mem_ram_show}GB${RESTORE}" ; 
                                      else free_mem_ram_show="${BOLD}${free_mem_ram_show}MB${RESTORE}"; fi
if [ "$free_mem_swap_show" -gt 9999 ]; then free_mem_swap_show=$(( free_mem_swap_show / 1024)); free_mem_swap_show="${BOLD}${free_mem_swap_show}GB${RESTORE}"; 
                                       else free_mem_swap_show="${BOLD}${free_mem_swap_show}MB${RESTORE}"; fi
echo "Hostname: ${BOLD}${HOSTNAME}${RESTORE} | Processors: ${BOLD}$(nproc)${RESTORE} | Free RAM: ${free_mem_ram_show} | Free swap: ${free_mem_swap_show}"
echo "Page size: ${BOLD}${DB_PAGE_SIZE_KB}${RESTORE} | Trace flags in RUN-file: ${BOLD}$flags_infile${RESTORE} | Active flags for the session: ${BOLD}$flags_insession${RESTORE}"
}


check_ase(){
if [[ $(showserver | egrep -v UID | egrep -v '\-m' | egrep -v _BS | grep "$sybase_user") ]]; 
                 then check_ase_text="ASE/BS ${BOLD}${GREEN}online${RESTORE}"; check_ase=1;
                      elif [[ $(showserver | grep '\-m' | egrep -v UID | grep "$sybase_user") ]]; 
                          then check_ase_text="ASE/BS ${BOLD}${RED}online(single mode)${RESTORE}"; check_ase=1 
                          else check_ase_text="ASE/BS ${BOLD}${RED}offline${RESTORE}"; check_ase=0; fi
if [[ $(showserver | egrep -v UID | egrep -v '\-m' | grep _BS | grep "$sybase_user") ]]; 
          then check_dbase_text="${BOLD}${GREEN}online${RESTORE}"; check_dbase=1; 
          else check_dbase_text="${BOLD}${RED}offline${RESTORE}"; check_dbase=0; fi

}


check_ase_root(){
if [[ $(su $sybase_user -c "showserver | egrep -v UID | egrep -v '\-m' | egrep -v _BS | grep $sybase_user") ]]; then check_ase_text="ASE/BS ${BOLD}${GREEN}online${RESTORE}"; check_ase_status=1;
                 elif [[ $(su $sybase_user -c "showserver | grep '\-m' | egrep -v UID | grep $sybase_user") ]]; then check_ase_text="ASE/BS ${BOLD}${RED}online(single mode)${RESTORE}"; check_ase_status=1
                                                                                                                else check_ase_text="ASE/BS ${BOLD}${RED}offline${RESTORE}"; check_ase_status=0; fi
if [[ $(su $sybase_user -c "showserver | egrep -v UID | egrep -v '\-m' | grep _BS | grep $sybase_user") ]]; then check_dbase_text="${BOLD}${GREEN}online${RESTORE}"; check_dbase_status=1;
                                                                                                            else check_dbase_text="${BOLD}${RED}offline${RESTORE}"; check_dbase_status=0; fi
}

top_info_root(){
check_java
check_abap
check_ase_root
echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S') | $ase_version | $check_ase_text/$check_dbase_text | $sap_abap_status_text"
free_mem_ram_show=$(free_mem_ram)
free_mem_swap_show=$(free_mem_swap)
if [ "$free_mem_ram_show" -gt 9999 ]; then free_mem_ram_show=$(( free_mem_ram_show / 1024)); free_mem_ram_show="${BOLD}${free_mem_ram_show}GB${RESTORE}" ; 
                                      else free_mem_ram_show="${BOLD}${free_mem_ram_show}MB${RESTORE}"; fi
if [ "$free_mem_swap_show" -gt 9999 ]; then free_mem_swap_show=$(( free_mem_swap_show / 1024)); free_mem_swap_show="${BOLD}${free_mem_swap_show}GB${RESTORE}"; 
                                       else free_mem_swap_show="${BOLD}${free_mem_swap_show}MB${RESTORE}"; fi
echo "Hostname: ${BOLD}${HOSTNAME}${RESTORE} | Processors: ${BOLD}$(nproc)${RESTORE} | Free RAM: ${free_mem_ram_show} | Free swap: ${free_mem_swap_show}"
}


dbproc(){
if [[ $(showserver | egrep -v UID | egrep -v '\-m') ]]; then return=1; else return=0; fi  
}

#check_passwd(){
#if [[ $(showserver | egrep -v UID) ]]; then while [ -z "$PASSWD_OK" ]; 
#do read -p "${GREEN}Enter the sapsa's password for $SYBASE_SID and press 'Enter': ${RESTORE}" SA_PASSWD
#   isql_passwd_check; server_version; get_sap_schema; echo PASSWD_OK = $PASSWD_OK; done; fi
#}


#isql_passwd_check(){
#if isql_check; then PASSWD_OK=1; else echo "ERROR: The password is not accepted!"; unset SA_PASSWD; fi
#}

#isql_check(){
#isql_request_nocolumns_nobold "use master" 
#}

isql_check(){
isql_session <<EOF
use master
go
exit
EOF
}

isql_check_root(){
isql_session_e_root <<EOF
use master
go
exit
EOF
}

check_passwd(){
if [[ $(showserver | egrep -v UID) ]]; then while [ -z "$PASSWD_OK" ]; 
do read -s -p "Enter sapsa's password for ${GREEN}$SYBASE_SID${RESTORE} and press 'Enter': " SA_PASSWD
   isql_passwd_check; server_version; get_sap_schema; DB_USER=SAPSA; done; fi
}

check_passwd_root(){
if [[ $(su "$sybase_user" -c "showserver | egrep -v UID") ]]; then while [ -z "$PASSWD_OK" ]; 
do read -s -p "Enter the ${GREEN}sapsa's password for $SYBASE_SID${RESTORE} and press 'Enter': " SA_PASSWD
   isql_passwd_check_root; server_version_root; #get_sap_schema; 
   DB_USER=SAPSA; done; fi
}

check_userstorekey(){
if [[ $(showserver | egrep -v UID) ]];
        then echo; echo "The next keys are available:"; aseuserstore list | egrep -v PASSWORD | egrep -v CON_ENV; 
             while [ -z "$STORE_KEY" ]; do echo; read -p "Enter valid ASEUSERSTORE-key (preferable: ${GREEN}sapsa${RESTORE}) for $SYBASE_SID: " STORE_KEY
				     isql_key_check; server_version; get_sap_schema; done; fi
             DB_USER=$(aseuserstore list "$STORE_KEY" | grep USERNAME | sed 's/^[^:]*://g' | xargs | tr [a-z] [A-Z])
}


check_userstorekey_root(){
if [[ $(su "$sybase_user" -c "showserver | egrep -v UID") ]];
        then echo; echo "The next keys are available:"; su "$sybase_user" -c "aseuserstore list | egrep -v PASSWORD | egrep -v CON_ENV"; 
             while [ -z "$STORE_KEY" ]; do echo; read -p "Enter valid ASEUSERSTORE-key (preferable: ${GREEN}sapsa${RESTORE}) for $SYBASE_SID: " STORE_KEY
				     isql_key_check_root; server_version_root; #get_sap_schema; 
             done; fi
             ########DB_USER=$(su "$sybase_user" -c "aseuserstore list ${STORE_KEY} | grep USERNAME | sed 's/^[^:]*://g' | xargs | tr [a-z] [A-Z]")
}

isql_request(){
isql_session_b <<EOF
SET NOCOUNT ON
SET PROC_RETURN_STATUS OFF
${1}
go
${2}
go
exit
EOF
echo
}


#isql_request_columns_bold(){
#isql_session_bold <<EOF
#SET NOCOUNT ON
#SET PROC_RETURN_STATUS OFF
#go
#${1}
#go
#${2}
#go
#${3}
#go
#${4}
#go
#${5}
#go
#${6}
#go
#exit
#EOF
#echo
#}

isql_request_columns_bold(){
if [ ${#arr_traceflags_commands[@]} -eq 0 ]; then isql_session_bold <<EOF
SET NOCOUNT ON
SET PROC_RETURN_STATUS OFF
go
${1}
go
${2}
go
${3}
go
${4}
go
${5}
go
${6}
go
exit
EOF
else count=1; for e in "${arr_traceflags_commands[@]}"; do export line_$count="$e"; count=$(($count+1)); done
isql_session_bold <<EOF
SET NOCOUNT ON
SET PROC_RETURN_STATUS OFF
go
${1}
${line_1}
${line_2}
${line_3}
${line_3}
${line_4}
${line_5}
${line_6}
${line_7}
${line_8}
${line_9}
go
${2}
go
${3}
go
${4}
go
${5}
go
${6}
go
exit
EOF
fi; echo
}


#isql_request_columns_nobold(){
#isql_session <<EOF
#SET NOCOUNT ON
#SET PROC_RETURN_STATUS OFF
#go
#${1}
#go
#${2}
#go
#${3}
#go
#${4}
#go
#${5}
#go
#${6}
#go
#exit
#EOF
#echo
#}

isql_request_columns_nobold(){
if [ ${#arr_traceflags_commands[@]} -eq 0 ]; then isql_session <<EOF
SET NOCOUNT ON
SET PROC_RETURN_STATUS OFF
go
${1}
go
${2}
go
${3}
go
${4}
go
${5}
go
${6}
go
exit
EOF
else count=1; for e in "${arr_traceflags_commands[@]}"; do export line_$count="$e"; count=$(($count+1)); done
isql_session <<EOF
SET NOCOUNT ON
SET PROC_RETURN_STATUS OFF
go
${1}
${line_1}
${line_2}
${line_3}
${line_3}
${line_4}
${line_5}
${line_6}
${line_7}
${line_8}                                             
${line_9}
go
${2}
go
${3}
go
${4}
go
${5}
go
${6}
go
exit
EOF
fi; echo
}


isql_request_nocolumns_verbose_root(){
isql_session_e_root <<EOF
${1}
go
${2}
go
${3}
go
${4}
go
${5}
go
${6}
go
exit
EOF
echo
return $?
}

isql_request_nocolumns_nobold(){
if [ ${#arr_traceflags_commands[@]} -eq 0 ]; then isql_session_b <<EOF
SET NOCOUNT ON
go
${1}
go
${2}
go
${3}
go
${4}
go
${5}
go
${6}
go
exit
EOF
echo
else count=1; for e in "${arr_traceflags_commands[@]}"; do export line_$count="$e"; count=$(($count+1)); done
isql_session_b <<EOF
SET NOCOUNT ON
go
${1}
${line_1}
${line_2}
${line_3}
${line_3}
${line_4}
${line_5}
${line_6}
${line_7}
${line_8}
${line_9}
go
${2}
go
${3}
go
${4}
go
${5}
go
${6}
go
exit
EOF
#echo "DEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUGDEBUG"
echo; fi
}


#isql_request_nocolumns_bold(){
#isql_session_bold <<EOF
#${1}
#go
#${2}
#go
#${3}
#go
#${4}
#go
#${5}
#go
#${6}
#go
#exit
#EOF
#echo
#}

isql_request_nocolumns_bold(){
if [ ${#arr_traceflags_commands[@]} -eq 0 ]; then isql_session_bold <<EOF
SET NOCOUNT ON
go
${1}
go
${2}
go
${3}
go
${4}
go
${5}
go
${6}
go
exit
EOF
else count=1; for e in "${arr_traceflags_commands[@]}"; do export line_$count="$e"; count=$(($count+1)); done
isql_session_bold <<EOF
SET NOCOUNT ON
go
${1}
${line_1}
${line_2}
${line_3}
${line_3}
${line_4}
${line_5}
${line_6}
${line_7}
${line_8}
${line_9}
go
${2}
go
${3}
go                                                                                                          
${4}
go
${5}
go
${6}
go
exit
EOF
fi; echo
}

isql_request_nocolumns_nobold_verbose(){
if [ ${#arr_traceflags_commands[@]} -eq 0 ]; then 
isql_session_e <<EOF
SET NOCOUNT ON
go
${1}
go
${2}
go
${3}
go
${4}
go
${5}
go
${6}
go
exit
EOF
else count=1; for e in "${arr_traceflags_commands[@]}"; do export line_$count="$e"; count=$(($count+1)); done
isql_session_e <<EOF
SET NOCOUNT ON
go
${1}
${line_1}
${line_2}
${line_3}
${line_3}
${line_4}
${line_5}
${line_6}
${line_7}
${line_8}
${line_9}
go
${2}
go
${3}
go
${4}
go
${5}
go
${6}
go
exit
EOF
fi; echo
}

#isql_request_from_array(){
#count=1
#arr="$1"
##for entry in "${arr_traceflags_commands[@]}"; 
#for e in "${"$arr"[@]}"; do export line_$count="$e"; count=$(($count+1)); done
#isql_session <<EOF
#${line_1}
#${line_2}
#${line_3}
#${line_3}
#${line_4}
#${line_5}
#${line_6}
#go
#exit
#EOF
#unset count; echo
#}

free_mem_ram(){
free -m | grep Mem | awk '{ print $4 }'
}

free_mem_swap(){
free -m | grep Swap | awk '{ print $4 }'
}


isql_passwd_check(){
if isql_check; then PASSWD_OK=1; else echo "${RED}ERROR: The password is not accepted!${RESTORE}"; unset SA_PASSWD; fi
}


isql_passwd_check_root(){
if isql_check_root; then PASSWD_OK=1; else echo "${RED}ERROR: The password is not accepted!${RESTORE}"; unset SA_PASSWD; fi
}


isql_key_check(){
if isql_check; then KEY_OK=1; else echo "${RED}ERROR: The key is not accepted!${RESTORE}"; unset STORE_KEY; fi
}

isql_key_check_root(){
if isql_check_root; then KEY_OK=1; else echo "${RED}ERROR: The key is not accepted!${RESTORE}"; unset STORE_KEY; fi
}

isql_sp_who(){
isql_session <<EOF
SET NOCOUNT ON
SET PROC_RETURN_STATUS OFF
select spid, cmd, status, hostname, clientname, clientapplname, priority from master..sysprocesses
go
exit
EOF
while true; do read -p "To kill session enter the spid or press 'b' to back): " answer
        case "$answer" in *[0-9]*) break;;
                                *) set_page;; esac; done;
string="kill $answer"
while [ "$run" != 1 ]; do echo  
        echo "The next command will be executed:"
        echo "${GREEN}${string}"
        echo "${string2}${RESTORE}"
        read -p "Proceed? [y - yes, e - edit, b - back]: " answer
        case "$answer" in
                    y) run=1; break;;
                    e) run=0; read -p "$string1 -> " string1;;
                    b) set_page;; esac; done;

isql_request_columns_bold "use master" "$string1"
tail_rows "1"
pause; set_page
}

#isql_check(){
#isql_request_nocolumns_nobold "use master" 
#}

session_name(){
ex_log=$(ps -ef | egrep -v grep | grep -i ASETOOLS | grep tee)
while [ ! -z "$ex_log" ]; do  
                   ex_log_file=$(echo $ex_log| awk '{ print $10 }')
                   ex_log_proc=$(echo $ex_log| awk '{ print  $2 }')
                   echo "${RED}Active session detected!${RESTORE}" 
                   echo "Active log file: ${BOLD}${ex_log_file}${RESTORE}";
                   echo "Active process: ${BOLD}${ex_log_proc}${RESTORE}";   
                   read -p "Do you want to display the session (y), kill it (k), proceed(p) or press (n) to exit? " par00;
             case "$par00" in y) tail -f "$ex_log_file";;
                              k) kill "$ex_log_proc"; exit 0;;
                              n) exit 0;;
                              p) break; esac; done   
echo "HINT: The script parameter 'nokey' prevents using aseuserstore-keys."
read -p "Enter your ${GREEN}last name${RESTORE} or ${GREEN}ticket number ${RESTORE}to tag the new log-file: " tdsuser; 
DT=$(date '+%Y%m%d_%H%M%S'); LOG_FILE="/sybase/${SYBASE_SID}/_ASETOOLS_$(hostname)_${SYBASE_SID}_${DT}_${tdsuser}.LOG";
}

passwd_or_key(){
#echo "HINT: The script parameter 'nokey' prevents using aseuserstore-keys."
if aseuserstore -v &>/dev/null; then if [[ "$s1" == "nokey" ]]; then check_passwd; else check_userstorekey; fi; else check_passwd; fi
#clear
exec &> >(tee -a "$LOG_FILE")
#echo "INFO: Read the log files with \"less -r\"!"
}

passwd_or_key_root(){
if su "$sybase_user" -c "aseuserstore -v > /dev/null"; then if [[ "$s1" == "nokey" ]]; then check_passwd_root; else check_userstorekey_root; fi; else check_passwd_root; fi
#clear
exec &> >(tee -a "$LOG_FILE")
#echo "INFO: Read the log files with \"less -r\"!"
}

startdb(){
echo
echo "The Database ${GREEN}$SYBASE_SID${RESTORE} will be start with the commands:"
echo "${GREEN} startserver -f $run_file"
echo " startserver -f $run_file_bkp${RESTORE}"
ask_proceed_yn
startserver -f "$run_file"
startserver -f "$run_file_bkp"
sleep 20; echo 
passwd_or_key; set_page
}

startdb_root(){
#echo
#echo "The Database ${GREEN}$SYBASE_SID${RESTORE} will be start with the commands:"
#echo "${GREEN} startserver -f $run_file"
#echo " startserver -f $run_file_bkp${RESTORE}"
su $sybase_user -c "startserver -f '$run_file'" &
pid1=$?
su $sybase_user -c "startserver -f '$run_file_bkp'" &
pid2=$?
sleep 20; echo 
#while kill -0 $pid1 2>/dev/null; do sleep 1; done
#while kill -0 $pid2 2>/dev/null; do sleep 1; done
passwd_or_key_root
}

startdb_root_menu(){
echo
echo "The Database ${GREEN}$SYBASE_SID${RESTORE} will be start with the commands:"
echo "${GREEN} startserver -f $run_file"
echo " startserver -f $run_file_bkp${RESTORE}"
ask_proceed_yn

#su $sybase_user -c "startserver -f '$run_file'"
#su $sybase_user -c "startserver -f '$run_file_bkp'"
#passwd_or_key_root
su $sybase_user -c "startserver -f '$run_file'" & 
pid1=$?
su $sybase_user -c "startserver -f '$run_file_bkp'" &
pid2=$?
sleep 20; echo 
#while kill -0 $pid1 2>/dev/null; do sleep 1; done
#while kill -0 $pid2 2>/dev/null; do sleep 1; done
passwd_or_key_root
#sleep 20; echo 
#set_page
}


stopdb(){
echo
echo "**********************************************************************************************************"
echo                         
echo "The Database ${GREEN}$SYBASE_SID${RESTORE} will be stopped with the commands:"
echo "${GREEN} shutdown SYB_BACKUP"   
echo " shutdown${RESTORE}"
echo
while true; do read -p "${RED}DO YOU WANT TO STOP THE DATABASE ${GREEN}$SYBASE_SID ${RED}?${RESTORE} [yes] or [no]: " yn
        case "$yn" in yes) break;;
                       no) set_page;; esac; done;
                         
#while true; do read -p "Have you set a blackout for the server ${BOLD}$HOSTNAME${RESTORE}? [y] or [n]: " yesno
#        case "$yesno" in y) break;;
#                         n) set_page;; esac; done;
                      
                     
isql_request_nocolumns_nobold "use master" "shutdown SYB_BACKUP" "shutdown" 
sleep 6; pause; set_page
}

stopdb_root(){
echo
echo "**********************************************************************************************************"
echo "The Database ${GREEN}$SYBASE_SID${RESTORE} will be stopped with the commands:"
echo "${GREEN} shutdown SYB_BACKUP"   
echo " shutdown${RESTORE}"
#while true; do read -p "${RED}DO YOU WANT TO STOP THE DATABASE ${GREEN}$SYBASE_SID ${RED}?${RESTORE} [yes] or [no]: " yn
#        case "$yn" in yes) break;;
#                       no) set_page;; esac; done;

isql_request_nocolumns_verbose_root "use master" "shutdown SYB_BACKUP" "shutdown" 
sleep 6;
}

stopdb_root_menu(){
echo
echo "**********************************************************************************************************"
echo "The Database ${GREEN}$SYBASE_SID${RESTORE} will be stopped with the commands:"
echo "${GREEN} shutdown SYB_BACKUP"   
echo " shutdown${RESTORE}"
while true; do read -p "${RED}DO YOU WANT TO STOP THE DATABASE ${GREEN}$SYBASE_SID ${RED}?${RESTORE} [yes] or [no]: " yn
        case "$yn" in yes) break;;
                       no) set_page;; esac; done;

isql_request_nocolumns_verbose_root "use master" "shutdown SYB_BACKUP" "shutdown" 
sleep 6; set_page
}


start_backup_server(){
echo
echo "The Backup-Server for ${GREEN}$SYBASE_SID${RESTORE} will be start with the command:"
echo "${GREEN} startserver -f $run_file_bkp${RESTORE}"
ask_proceed_yn
startserver -f "$run_file_bkp" &
sleep 5; echo 
#passwd_or_key
set_page
}


stop_backup_server(){
echo
echo "**********************************************************************************************************"
while true; do read -p "DO YOU WANT TO STOP THE BACKUP-SERVER FOR ${GREEN}$SYBASE_SID${RESTORE} with the command '${GREEN}shutdown SYB_BACKUP${RESTORE}'? [yes] or [no]: " yesno
        case "$yesno" in yes) break;;
                         no) set_page;; esac; done;
echo "**********************************************************************************************************"
isql_request_nocolumns_nobold "use master" "shutdown SYB_BACKUP" "exit"
sleep 5; set_page
}

startdb_single(){
#if [[ $(showserver | egrep -v UID | egrep -v '\-m') ]]; then echo "== 0"; echo "${BOLD} WARNING: Firstly stop the database and repeat this action${RESTORE}"; pause; set_page; fi  
echo "${RED}The database will be stopped ${RESTORE}and started in the single-mode:"
echo " ${GREEN}shutdown SYB_BACKUP"
echo " shutdown"
echo " startserver -f $run_file -m ${RESTORE}"
ask_proceed_yn
isql_request_nocolumns_nobold "use master" "shutdown SYB_BACKUP" "shutdown" 
startserver -f "$run_file" -m 
sleep 13; pause; set_page
}


startsap(){
su "$adm_user" -c "startsap"
check_java
check_abap
}

startsap_menu(){
ask_proceed_yn
su "$adm_user" -c "startsap"
set_page
}

stopsap(){
su "$adm_user" -c "stopsap r3"
check_java
check_abap
}

stopsap_menu(){
ask_proceed_yn
su "$adm_user" -c "stopsap r3"
set_page
}

put_db_to_single(){
isql_db_list
par20=$(isql_request "use master" "select name from sysdatabases")
SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"

while true; do echo; read -p "Enter the ${BOLD}database name${RESTORE} that must be put in single-user mode: " par21
if [[ " ${par20[@]} " =~ " ${par21} " ]]; then :; break; else echo "${RED}WARN: Enter a valid database name!${RESTORE}"; fi; done

echo "Generated command(s):"
string1="use master"
string2="sp_dboption $par21, single, true"
string3="use $par21"
string4="checkpoint"

echo "${GREEN}"
echo " $string1"
echo " $string2"
echo " $string3"
echo " $string4"
echo "${RESTORE}"

ask_proceed_yn
isql_request_nocolumns_nobold "$string1" "$string2" "$string3" "$string4"
pause; set_page
}

put_db_from_single(){
isql_db_list
par20=$(isql_request "use master" "select name from sysdatabases")
SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"

while true; do echo; read -p "Enter the ${BOLD}database name${RESTORE} that must be put in single-user mode: " par21
if [[ " ${par20[@]} " =~ " ${par21} " ]]; then :; break; else echo "${RED}WARN: Enter a valid database name!${RESTORE}"; fi; done

echo "Generated command(s):"
string1="use master"
string2="sp_dboption $par21, single, false"
string3="use $par21"
string4="checkpoint"

echo "${GREEN}"
echo " $string1"
echo " $string2"
echo "${RESTORE}"

ask_proceed_yn
isql_request_nocolumns_nobold "$string1" "$string2"
pause; set_page
}


isql_session(){
if [ -z "$STORE_KEY" ]; then isql -Usapsa -S"$SYBASE_SID" -w1024 -X -P"$SA_PASSWD"; else isql -k "$STORE_KEY" -w1024 -X; fi
}

isql_session_bold(){
bold_text
if [ -z "$STORE_KEY" ]; then isql -Usapsa -S"$SYBASE_SID" -w1024 -X -P"$SA_PASSWD"; else isql -k "$STORE_KEY" -w1024 -X; fi
}

#isql -b - no columns
isql_session_b(){
if [ -z "$STORE_KEY" ]; then isql -Usapsa -S"$SYBASE_SID" -w1024 -X -b -P"$SA_PASSWD"; else isql -k "$STORE_KEY" -w1024 -X -b; fi
}

#isql -e - verbose output
isql_session_e(){
if [ -z "$STORE_KEY" ]; then isql -Usapsa -S"$SYBASE_SID" -w1024 -X -b -e -P"$SA_PASSWD"; else isql -k "$STORE_KEY" -w1024 -X -b -e; fi
}

isql_session_e_root(){
if [ -z "$STORE_KEY" ]; then su "$sybase_user" -c "isql -Usapsa -S${SYBASE_SID} -w1024 -X -b -e -P${SA_PASSWD}"; else su "$sybase_user" -c "isql -k ${STORE_KEY} -w1024 -X -b -e"; fi
}

isql_session_getOwner(){
if [ -z "$STORE_KEY" ]; then isql -Usapsa -S"$SYBASE_SID" -w1024 -X -b -P"$SA_PASSWD"; else isql -k "$STORE_KEY" -w1024 -X -b; fi
}

isql_user_session(){
echo; echo "Welcome to isql as user ${DB_USER}. Go to SAP schema:"
echo "${GREEN}use ${SYBASE_SID}" 
echo "setuser \"${SAP_SCHEMA}\""
echo "dbcc traceon(3604)  // Directs trace output to the client, rather than to the error log."
echo "go${RESTORE}"
if [ ! -z $(get_flags_session) ]; then echo "Please apply trace flags manually, if you need it: ${GREEN}dbcc traceon ($flags_insession)${RESTORE}"; fi
#isql -Usapsa -S"$SYBASE_SID" -w1024 -X -P"$SA_PASSWD"
isql_session
echo; echo "See you later."
set_page
}

isql_user_session_root(){
echo; echo "Welcome to isql as user ${DB_USER}. Go to SAP schema:"
#echo "${GREEN}use ${SYBASE_SID}" 
#echo "setuser \"${SAP_SCHEMA}\""
#echo "go${RESTORE}"
#if [ ! -z $(get_flags_session) ]; then echo "Please apply trace flags manually, if you need it: ${GREEN}dbcc traceon ($flags_insession)${RESTORE}"; fi
#isql -Usapsa -S"$SYBASE_SID" -w1024 -X -P"$SA_PASSWD"
isql_session_e_root
echo; echo "See you later."
set_page
}


dbcc_traceon(){
echo
while [[ -z "$par00" ]]; do read -p "Enter the trace numbers, which must be ${BOLD}activated${RESTORE} (delimiter ','): " par00; done

delimiter=","; s1=$par00$delimiter; s2=$par00$delimiter;
unset arr_traceflags_numbers_new; unset arr_traceflags_commands_new;

if [ ${#arr_traceflags_numbers[@]} -eq 0 ]; 
  then while [[ $s1 ]]; do arr_traceflags_numbers_new+=( "${s1%%"$delimiter"*}" ); s1=${s1#*"$delimiter"}; done;
       while [[ $s2 ]]; do arr_traceflags_commands_new+=( "dbcc traceon (${s2%%"$delimiter"*})" ); s2=${s2#*"$delimiter"}; done;
  else while [[ $s1 ]]; do arr_traceflags_numbers_new+=( "${s1%%"$delimiter"*}" ); s1=${s1#*"$delimiter"}; done;
       for e in "${arr_traceflags_numbers_new[@]}"; do if [[ "${arr_traceflags_numbers[@]}" = "${e}" ]]; 
                                                          then echo "INFO: Trace flag $e already set. Skipped."
                                                          else arr_traceflags_commands_new+=( "dbcc traceon ("$e")" ); fi; done; fi                                                        

#count=0; for e in "${arr_traceflags_numbers[@]}"; do if [ -z "$e" ]; then unset arr_traceflags_numbers[$count]; fi; done 

echo "Generated iSQL-command(s):"
for command in "${arr_traceflags_commands_new[@]}"; do echo "${GREEN} $command ${RESTORE}"; done;


echo "INFO: Changes in RUN-file will be applied"
for e in "${arr_traceflags_numbers_new[@]}"; do
        if [[ "$e" =~ ^[0-9] ]] || [ -z "$e" ]; then 
                if grep "^-T${e} " "$run_file" >/dev/null; 
                    then :; 
                    else echo "${GREEN} Flag $e will be added to RUN-file${RESTORE}"; fi; 
            else echo "WARN: Not numeric value or empty. Skipped"; fi; done
                    
ask_proceed_yn

for e in "${arr_traceflags_numbers_new[@]}"; do arr_traceflags_numbers+=( "$e" ); done                    

for e in "${arr_traceflags_numbers[@]}"; do if [[ "$e" =~ ^[0-9] ]] || [ -z "$e" ]; 
                                            then if grep "^-T${e} " "$run_file" >/dev/null; 
                                                    then echo "Flag $e is already set in file. Skipped"; 
                                                    else echo "-T${e} \\" >> "$run_file"; echo "${BOLD}Flag $e added to RUN-file${RESTORE}";
                                                         sed -i '/^$/d' "$run_file"; fi; 
                                            else echo "WARN: Not numeric or empty value. Skipped"; fi; done
echo "${BOLD}Empty line added${RESTORE}"; echo "" >> "$run_file"
isql_request_nocolumns_nobold "use master" "dbcc traceflags" 
set_page
}


dbcc_traceoff(){
echo                                                                      
while [[ -z "$par00" ]]; do read -p "Enter the trace number(s), which must be ${BOLD}deactivated${RESTORE} (delimiter ','): " par00; done
delimiter=","; s1=$par00$delimiter; s2=$par00$delimiter
unset arr_traceflagoff_numbers_show; unset arr_traceflagoff_commands_show 


while [[ $s1 ]]; do arr_traceflagoff_numbers_show+=( "${s1%%"$delimiter"*}" ); s1=${s1#*"$delimiter"}; done;

for e in ${arr_traceflagoff_numbers_show[@]}; do arr_traceflagoff_commands_show+=( "dbcc traceoff ("$e")" ); done;

echo "${GREEN}Generated iSQL-command(s):${RESTORE}" 
for e in "${arr_traceflagoff_commands_show[@]}"; do echo "${GREEN} $e${RESTORE}"; done


echo "INFO: RUN-file changes:"
for e in "${arr_traceflagoff_numbers_show[@]}"; do if [[ "$e" =~ ^[0-9] ]] || [ ! -z "$e" ]; then 
                if grep "^-T${e} " "$run_file" >/dev/null; then :; else echo "${GREEN}Flag $e will be deleted from RUN-file (if exists)${RESTORE}"; fi; 
            else echo "WARN: Not numeric value or empty. Skipped"; fi; done;

ask_proceed_yn

for target in "${arr_traceflagoff_numbers_show[@]}"; do
  for i in "${!arr_traceflags_numbers[@]}"; do if [[ ${arr_traceflags_numbers[i]} = $target ]]; then unset 'arr_traceflags_numbers[i]'; fi; done; done              

count=0; for e in ${arr_traceflags_numbers[@]}; do if [[ -z "$e" ]]; then unset arr_traceflags_numbers[$count]; count=$((count + 1)); fi; done

for e in ${arr_traceflags_numbers[@]}; do arr_traceflags_commands+=( "dbcc traceon ($e)" ); done;
for e in ${arr_traceflag_commands[@]}; do isql_request_nocolumns_nobold_verbose "$e"; done

#echo "INFO: RUN-file changes:"
for e in "${arr_traceflagoff_numbers_show[@]}"; do 
        if [[ "$e" =~ ^[0-9] ]] || [ -z "$e" ]; 
            then if grep "^-T${e} " "$run_file" >/dev/null;
                   then sed -i "/^-T$e $*/d" "$run_file"; 
                        echo "${BOLD}Flag $e deleted from RUN-file${RESTORE}"; fi 
            else echo "WARN: Not numeric or empty value. Skipped"; fi; done
echo "" >> "$run_file";
set_page
}

show_devices(){
isql_request_columns_bold "use master" "sp_helpdevice"; pause; set_page
}

show_memory(){
isql_request_columns_bold "use master" "sp_monitorconfig 'all',null ,'full'"; pause; set_page
}



data_log_sizes_all_sql(){
isql_session <<EOF 
select db_name(d.dbid) as DB_name,
convert(varchar(10),ceiling(sum(case when u.segmap != 4 and vdevno >= 0 then (u.size/1048576.)*@@maxpagesize end ))) as DB_size_MB,
convert(varchar(10),ceiling(sum(case when u.segmap != 4 and vdevno >= 0 then size - curunreservedpgs(u.dbid, u.lstart, u.unreservedpgs) end)/1048576.*@@maxpagesize)) as Data_used_MB,
convert(varchar(10),ceiling(100 * (1 - 1.0 * sum(case when u.segmap != 4 and vdevno >= 0 then curunreservedpgs(u.dbid, u.lstart, u.unreservedpgs) end) / sum(case when u.segmap != 4 then u.size end)))) as "Data_used_%",
convert(varchar(10),ceiling(sum(case when u.segmap = 4 and vdevno >= 0 then u.size/1048576.*@@maxpagesize end))) as Log_size_MB,
convert(varchar(10),ceiling(sum(case when u.segmap = 4 and vdevno >= 0 then u.size/1048576.*@@maxpagesize end) - lct_admin("logsegment_freepages",d.dbid)/1048576.*@@maxpagesize)) as Log_used_MB,
convert(varchar(10),ceiling(100 * (1 - 1.0 * lct_admin("logsegment_freepages",d.dbid) / sum(case when u.segmap in (4, 7) and vdevno >= 0 then u.size end)))) as "Log_used_%" 
from master..sysdatabases d, master..sysusages u
where u.dbid = d.dbid  and d.status != 256
group by d.dbid
order by db_name(d.dbid)
go
exit
EOF
}

data_log_sizes_all(){
data_log_sizes_all_sql
pause; set_page
}

data_log_sizes_all_sql_sep(){
isql_session <<EOF 
select db_name(d.dbid) as DB_name,
convert(varchar(10),ceiling(sum(case when u.segmap != 4 and vdevno >= 0 then (u.size/1048576.)*@@maxpagesize end ))) as DB_size_MB,
convert(varchar(10),ceiling(sum(case when u.segmap != 4 and vdevno >= 0 then size - curunreservedpgs(u.dbid, u.lstart, u.unreservedpgs) end)/1048576.*@@maxpagesize)) as Data_used_MB,
convert(varchar(10),ceiling(100 * (1 - 1.0 * sum(case when u.segmap != 4 and vdevno >= 0 then curunreservedpgs(u.dbid, u.lstart, u.unreservedpgs) end) / sum(case when u.segmap != 4 then u.size end)))) as "Data_used_%",
convert(varchar(10),ceiling(sum(case when u.segmap = 4 and vdevno >= 0 then u.size/1048576.*@@maxpagesize end))) as Log_size_MB,
convert(varchar(10),ceiling(sum(case when u.segmap = 4 and vdevno >= 0 then u.size/1048576.*@@maxpagesize end) - lct_admin("logsegment_freepages",d.dbid)/1048576.*@@maxpagesize)) as Log_used_MB,
convert(varchar(10),ceiling(100 * (1 - 1.0 * lct_admin("logsegment_freepages",d.dbid) / sum(case when u.segmap in (4, 7) and vdevno >= 0 then u.size end)))) as "Log_used_%" 
from master..sysdatabases d, master..sysusages u
where u.dbid = d.dbid  and d.status != 256
group by d.dbid
order by db_name(d.dbid)
go
exit
EOF
}

isql_show_db_options(){
isql_request_columns_bold "use master" "sp_dboption"
isql_request_columns_bold "use master" "sp_configure"
pause; set_page
}


get_db_id(){
echo "Get db_id from db_name."
echo 
isql_db_list
par20=$(isql_request "use master" "select name from sysdatabases")
SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"
while true; do echo; read -p "Enter the ${BOLD}database name${RESTORE}: " par00
               if [[ " ${par20[@]} " =~ " ${par00} " ]]; then :; break; 
                                                         else echo "${RED}WARN: Enter a valid database name!${RESTORE}"; fi; done
par01="select db_id(\"$par00\")"
isql_request_nocolumns_bold "use master" "$par01" 
set_page
}


get_object_id(){
echo "Get object from object_id."
echo 
read -p "Enter the object id: " par00
read -p "Enter the db_id: " par01
par02="select object_name($par00,$par01)"
isql_request_nocolumns_bold "use master" "$par02"
set_page
}


resize_data_dev_TO_DELETE(){
par10=$(isql_request "use master" "select name from sysdevices where name not like '%log%'")
SAVEIFS="$IFS"; IFS=$'\n'; par10=($par10); IFS="$SAVEIFS"

par20=$(isql_request "use master" "select name from sysdatabases")
SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"

isql_request_columns_bold "use master" "sp_helpdevice"

while true; do echo; read -p "Enter the ${BOLD}database name${RESTORE} that must be resized: " par21
if [[ " ${par20[@]} " =~ " ${par21} " ]]; then :; break; else echo "${RED}WARN: Enter a valid database name!${RESTORE}"; fi; done


while true; do read -p "Enter the ${BOLD}data-device_name${RESTORE} that must be resized: " data_dev
if [[ " ${par10[@]} " =~ " ${data_dev} " ]]; then :; break; else echo "${RED}WARN: Enter a valid device_name!${RESTORE}"; fi; done

par11="sp_helpdevice $data_dev"
isql_request_columns_nobold "use master" "$par11"

par00=51200
par10="select phyname from sysdevices where name = '$data_dev'"
data_dev_file=$(isql_request "use master" "$par10"); data_dev_file=$(echo $data_dev_file)

db_dev_file_size=$(du -m $data_dev_file | awk '{ print $1 }' )
par11=$(df -m $data_dev_file | egrep -v Filesystem | awk '{ print $4 }')

compare_numbers "$db_dev_file_size" "$par00" "${RED}WARNING: The device $data_dev_file is already greater than $par00 megabytes. The device must be shrunk.${RESTORE}"; 
if [ "$go" == 0 ]; then set_page; fi; unset go

par01=$(( $par00 - $db_dev_file_size )) 

echo; go=0
while [[ "$go" = 0 ]]; do read -p "Enter the increment value in MB for $data_dev (it's max.: ${GREEN}$par01${RESTORE} megabytes): " data_dev_size
      compare_numbers "$data_dev_size" "$par01" "WARN: Maximum ${par00}M per file. If you need to add more space, please add more devices."
        if [[ "$go" = 0 ]]; then continue; fi 
      compare_numbers "$data_dev_size" "$par11" "WARN: Free space only ${par11}M"; done; unset go

string1="disk resize name=\"$data_dev\", size=\"${data_dev_size}M\""
string2="alter database $par21 on $data_dev=\"${data_dev_size}M\""

while true; do echo  
        echo "The next commands will be executed:"
        echo "${GREEN}${string1}"
        echo "${string2}${RESTORE}"
        read -p "Proceed? [y - yes, e - edit, b - back]: " yn
        case "$yn" in
                    y) break;;
                    e) read -p "$string1 -> " string1; read -p "$string2 -> " string2;;
                    b) set_page;; esac; done; echo

isql_request_columns_bold "use master" "$string1" "$string2"
pause; set_page
}


resize_data_dev_new(){
#clear
echo "Data-files resize"
echo
par10=$(isql_request "use master" "select name from sysdevices where name not like '%log%'")
SAVEIFS="$IFS"; IFS=$'\n'; par10=($par10); IFS="$SAVEIFS"

par20=$(isql_request "use master" "select name from sysdatabases")
SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"

data_log_sizes_all_sql
#isql_request_columns_bold "use master" "sp_helpdevice"

while true; do echo; read -p "Enter the ${BOLD}database name${RESTORE} that must be resized: " par21
if [[ " ${par20[@]} " =~ " ${par21} " ]]; then :; break; else echo "${RED}WARN: Enter a valid database name!${RESTORE}"; fi; done

#par99="select name as \"Device Name\", phyname as \"Physical Location\" from sysdevices where name like \"%${par21}%\" and name not like \"%log%\" order by 1"
par99="select name as \"Device Name\", phyname as \"Physical Location\" from sysdevices where name not like \"%log%\" order by 1"
isql_request_columns_bold "use master" "$par99"

while true; do read -p "Enter the ${BOLD}data-device name${RESTORE} of the ${par21} that must be resized: " data_dev
if [[ " ${par10[@]} " =~ " ${data_dev} " ]]; then :; break; else echo "${RED}WARN: Enter a valid device_name!${RESTORE}"; fi; done

#par11="sp_helpdevice $data_dev"
#isql_request_columns_nobold "use master" "$par11"

#par00=51200
par10="select phyname from sysdevices where name = '$data_dev'"
data_dev_file=$(isql_request "use master" "$par10"); data_dev_file=$(echo $data_dev_file)

db_dev_file_size=$(du -m $data_dev_file | awk '{ print $1 }' )
par11=$(df -m $data_dev_file | egrep -v Filesystem | awk '{ print $4 }')
par01=$(( 51200 - $db_dev_file_size ))

echo "INFO: Current file size of the data-device: ${BOLD}${db_dev_file_size}MB${RESTORE}"
echo "INFO: Maximal size of data-device should be: 51200MB"
#2echo "par11 = $par11"

#compare_numbers "$db_dev_file_size" "$par00" "${RED}WARNING: The device $data_dev_file is already greater than $par00 megabytes. The device must be shrunk.${RESTORE}"; 
#if [ "$go" == 0 ]; then set_page; fi; unset go

 

#echo; go=0
#while [[ "$go" = 0 ]]; do read -p "Enter the increment value in MB for $data_dev (it's max.: ${GREEN}$par01${RESTORE} megabytes): " data_dev_size
#      compare_numbers "$data_dev_size" "$par01" "WARN: Maximum ${par00}M per file. If you need to add more space, please add more devices."
#        if [[ "$go" = 0 ]]; then continue; fi 
#      compare_numbers "$data_dev_size" "$par11" "WARN: Free space only ${par11}M"; done; unset go

while true; do read -p "Enter increment value (in MB) (max. for the file: ${GREEN}$par01${RESTORE}; max. for the FS: ${RED}$par11${RESTORE}): " data_dev_size; 
               if [ "$data_dev_size" -gt "51200" ]; then echo "${RED}WARN: Datafile must be not greather than 51200MB${RESTORE}"
                                           else if [ "$data_dev_size" -gt "$par11" ]; then echo "${RED}WARN: Not enought free space. Maximal value: ${par11}MB${RESTORE}"; 
                                                                                                 else break; fi; fi; done

string1="disk resize name=\"$data_dev\", size=\"${data_dev_size}M\""
string2="alter database $par21 on $data_dev=\"${data_dev_size}M\""

while true; do echo  
        echo "The next commands will be executed:"
        echo "${GREEN}${string1}"
        echo "${string2}${RESTORE}"
        read -p "Proceed? [y - yes, e - edit, b - back]: " yn
        case "$yn" in
                    y) break;;
                    e) read -p "$string1 -> " string1; read -p "$string2 -> " string2;;
                    b) set_page;; esac; done; echo

isql_request_columns_bold "use master" "$string1" "$string2"
echo
data_log_sizes_all_sql
set_page
}

resize_log_dev(){
echo
echo "Log-device resize"
par20=$(isql_request "use master" "select name from sysdatabases")
SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"

isql_request_columns_bold "use master" "select name from sysdatabases"

isql_request_columns_bold "use master" "sp_helpdevice"


par10=$(isql_request "use master" "select name from sysdevices where name like '%data%'")
SAVEIFS="$IFS"; IFS=$'\n'; par10=($par10); IFS="$SAVEIFS"

echo
while true; do read -p "Enter the ${BOLD}database name${RESTORE} that must be resized: " par21
if [[ " ${par20[@]} " =~ " ${par21} " ]]; then :; break; else echo "${RED}WARN: Enter a valid database name!${RESTORE}"; fi; done

par99="select name as \"Log device name\", phyname as \"Physical location\" from sysdevices where name like \"%${par21}%\" and name not like \"%data%\" order by 1"
isql_request_columns_bold "use master" "$par99"


while true; do read -p "Enter the ${BOLD}data-device name${RESTORE} that must be resized: " log_dev
if [[ " ${par10[@]} " =~ " ${log_dev} " ]]; then :; break; else echo "${RED}WARN: Enter a valid device_name!${RESTORE}"; fi; done



par10="sp_helpdevice $log_dev"; isql_request_columns_nobold "use master" "$par10" 

echo 
echo "Enter the ${BOLD}increment value in MB${RESTORE} for the log-device $log_dev."
read -p "(HINT: The log-area should be 1,5 times bigger than it's data-area): " log_dev_size
string1="disk resize name=\"$log_dev\", size=\"${log_dev_size}M\""
string2="alter database $par21 log on $log_dev=\"${log_dev_size}M\""

while true; do echo  
        echo "The next commands will be executed:"
        echo "${GREEN}${string1}"
        echo "${string2}${RESTORE}"
        read -p "Proceed? [y - yes, e - edit, b - back]: " yn
        case "$yn" in
                    y) break;;
                    e) read -p "$string1 -> " string1; read -p "$string2 -> " string2;;
                    b) set_page;; esac; done;

isql_request_columns_bold "use master" "$string1" "$string2"
pause; set_page
}




create_new_devs_wiz(){
clear
echo "Create new data-device with the wizard"
echo
isql_request_columns_nobold "use master" "sp_helpdevice"
echo "Available databases:"
isql_db_list
echo
par20=$(isql_request "use master" "select name from sysdatabases"); SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"

while [ -z "$par21" ]; do read -p "Enter database name (or 'b' to return back): " par21
                          case "$par21" in b) set_page;;
                                           *) if [[ ! " ${par20[@]} " =~ " ${par21} " ]]; then echo "${RED}WARN: Enter a valid database name!${RESTORE}"; unset par21; continue; 
                                                                                          else break; fi; esac; done; 

#echo
#isql_request_columns_nobold "use master" "sp_helpdevice"
echo
#par01="select name as DeviceName, phyname as PhysicalLocation from sysdevices where name like \"%${par21}%\" and name not like '%log%' order by 1"
par01="select name as DeviceName, phyname as PhysicalLocation from sysdevices where name not like '%log%' order by 1"
isql_request_columns_nobold "use master" "$par01"


#isql_request_columns_nobold "use master" "select name as DeviceName, phyname as PhysicalLocation from sysdevices"
#echo "HINT: Possible parameters for the physical data-device or file creation:"
#echo " disk init name = \"device_name\","
#echo "	physname = { 'physical_name' | 'cache_name'}"
#echo "	skip_alloc={true | false},"
#echo "	[vdevno = virtual_device_number,]"
#echo "	size = number_of_blocks"
#echo "	[, type = 'inmemory' ]"
#echo "	[, vstart = virtual_address"
#echo "	[, cntrltype = controller_number]"
#echo "	[, dsync = {true | false}]"
#echo "	[, directio = {true | false}]"
#echo "	[, instance = \"instance_name\"]"

echo 
if [ "$par21" == "$SYBASE_SID" ]; then echo "Type the next 5 parameters for a new SAP data-file:"
  while [ -z "$disk_init_par12" ]; do read -p "1) sapdata number N (e.g. /sybase/${SYBASE_SID}/sapdata_${GREEN}N${RESTORE}): " disk_init_par12; done
  while [ -z "$disk_init_par13" ]; do read -p "2) device number for ${SYBASE_SID}_data_${GREEN}<Nr.>${RESTORE}, e.g. 002): " disk_init_par13;
  
       if [ ${#disk_init_par13} != 3 ]; then echo "${RED}ERROR: Device number should have only 3 digits!${RESTORE}"; unset disk_init_par13; continue; fi
       if [ "$disk_init_par13" == 000 ]; then echo "${RED}ERROR: Device number cannot be 000!${RESTORE}"; unset disk_init_par13; continue; fi
       disk_init_par1="${SYBASE_SID}_data_${disk_init_par13}"
       disk_init_par2="/sybase/${SYBASE_SID}/sapdata_${disk_init_par12}/${disk_init_par1}.dat"
       
       par30=$(isql_request "use master" "select name from sysdevices"); SAVEIFS="$IFS"; IFS=$'\n'; par30=($par30); IFS="$SAVEIFS"
       
       if [[ " ${par30[@]} " =~ " ${disk_init_par1} " ]]; then echo "${RED}WARN: Device name already exists in the $SYBASE_SID. Enter a valid device name!${RESTORE}"; unset disk_init_par13; continue; fi 
       if [ -e "$disk_init_par2" ]; then echo "${RED}ERROR: The data-file already exists: $disk_init_par2${RESTORE}"; unset disk_init_par2; unset disk_init_par13; continue; fi
       if touch "$disk_init_par2" 2>/dev/null; then disk_init_par21=$(df -m "$disk_init_par2" | egrep -v Filesystem | awk '{ print $4 }') 
       echo "INFO: ${GREEN}Free space ${disk_init_par21}MB${RESTORE}"; rm "$disk_init_par2"; break
       else echo "${RED}ERROR: Please check parent directory permissions of the new data-file: $disk_init_par2${RESTORE}"; unset disk_init_par2; fi; done
                                    else echo "Type the next 6 parameters for a new SYBASE data-file:"
  while [ -z "$disk_init_par12" ]; do read -p "1) directory name in /sybase/${SYBASE_SID}/, e.g. ${GREEN}$par21${RESTORE}): " disk_init_par12; done
  while [ -z "$disk_init_par14" ]; do read -p "2) file prefix for <${GREEN}$par21${RESTORE}>_data_${disk_init_par13}): " disk_init_par14; done
  while [ -z "$disk_init_par13" ]; do read -p "3) device number for ${par21}_data_${GREEN}<Nr.>${RESTORE}, e.g. 002): " disk_init_par13; 
       if [ ${#disk_init_par13} != 3 ]; then echo "${RED}ERROR: Device number should have only 3 digits!${RESTORE}"; unset disk_init_par13; continue; fi
       if [ "$disk_init_par13" == 000 ]; then echo "${RED}ERROR: Device number cannot be 000!${RESTORE}"; unset disk_init_par13; continue; fi 
       disk_init_par1="${disk_init_par14}_data_${disk_init_par13}"
       disk_init_par2="/sybase/${SYBASE_SID}/${disk_init_par12}/${disk_init_par1}.dat"
       
       par30=$(isql_request "use master" "select name from sysdevices"); SAVEIFS="$IFS"; IFS=$'\n'; par30=($par30); IFS="$SAVEIFS"
       if [[ " ${par30[@]} " =~ " ${disk_init_par1} " ]]; then echo "${RED}WARN: Device name already exists in the $SYBASE_SID. Enter a valid device name!${RESTORE}"; unset disk_init_par13; continue; fi
       if [ -e "$disk_init_par2" ]; then echo "${RED}WARN: The data-file already exists!${RESTORE}"; unset disk_init_par13; continue; fi
       if touch "$disk_init_par2" 2>/dev/null; then disk_init_par21=$(df -m "$disk_init_par2" | egrep -v Filesystem | awk '{ print $4 }') 
       echo "INFO: ${GREEN}Free space ${disk_init_par21}MB${RESTORE}"; rm "$disk_init_par2"; break;
       else echo "${RED}WARN: Please check parent directory permissions of the new file: $disk_init_par2${RESTORE}"; unset disk_init_par13; continue; fi; done; fi

while true; do read -p "3) size (in MB). Maximum: 51200MB: " disk_init_par4; 
               if [ "$disk_init_par4" -gt 51200 ]; then echo "${RED}WARN: Datafile must be not greather then 51200MB${RESTORE}"
                                           else if [ "$disk_init_par4" -gt "$disk_init_par21" ]; then echo "${RED}WARN: Not enought free space. Maximal size is ${disk_init_par21}MB${RESTORE}"; 
                                                                                                 else break; fi; fi; done
 
while true; do read -p "4) skip_alloc (true | ${GREEN}false${RESTORE} or [ENTER]): " disk_init_par3
        case "$disk_init_par3" in
		                [fF]*) disk_init_par3="false"; break;;
                    [tT]*) disk_init_par3="true"; break;;
                    "") disk_init_par3="false"; break;;
                    *) ;; esac; done

while true; do read -p "5) directio (false | ${GREEN}true${RESTORE} or [ENTER]): " disk_init_par10
        case "$disk_init_par10" in
		                [fF]*) disk_init_par10="false"; break;;
                    [tT]*) disk_init_par10="true"; break;;
                    "") disk_init_par10="true"; break;;
                    *) ;; esac; done                    

        

echo; echo "Type or skip [ENTER] the unnecessary parameters:"
read -p "6) vdevno (virtual_device_number): " disk_init_par5
read -p "7) type (inmemory): " disk_init_par6
read -p "8) vstart (virtual_address): " disk_init_par7
read -p "9) cntrltype (controller_number): " disk_init_par8
#echo "HINT: {RED}Never configure dysnc='true' for a Sybase device (exception is the master device, it always has the dsync attribute set, this cant get changed)${RESTORE}"
if [ "$par21" == "master" ]; then disk_init_par9=true; else disk_init_par9=false; fi 
read -p "10) instance (instance_name): " disk_init_par11
echo
if [ ! -z "$disk_init_par5" ]; then disk_init_par5=", vdevno=${disk_init_par5}"; fi
if [ ! -z "$disk_init_par6" ]; then disk_init_par6=", type=\"${disk_init_par6}\""; fi
if [ ! -z "$disk_init_par7" ]; then disk_init_par7=", vstart=${disk_init_par7}"; fi
if [ ! -z "$disk_init_par8" ]; then disk_init_par8=", cntrltype=${disk_init_par8}"; fi
if [ ! -z "$disk_init_par9" ]; then disk_init_par9=", dsync=${disk_init_par9}"; fi
if [ ! -z "$disk_init_par10" ]; then disk_init_par10=", directio=${disk_init_par10}"; fi
if [ ! -z "$disk_init_par11" ]; then disk_init_par11=", instance=\"${disk_init_par11}\""; fi

echo
echo "${GREEN}The next command has been generated:"
disk_init_par20="disk init name=\"${disk_init_par1}\", physname=\"${disk_init_par2}\", skip_alloc=\"${disk_init_par3}\", size=\"${disk_init_par4}M\"${disk_init_par5}${disk_init_par6}${disk_init_par7}${disk_init_par8}${disk_init_par9}${disk_init_par10}${disk_init_par11}"
par00="alter database $par21 on $disk_init_par1 = \"${disk_init_par4}M\""
echo " $disk_init_par20"
echo " $par00${RESTORE}"

ask_proceed_yn

isql_request_columns_nobold "use master" "$disk_init_par20" "$par00"
tail_rows "4" 
echo
isql_request_columns_nobold "use master" "$par01"

while true; do read -p "Add the next datafile? [y/n]: " yn
  case "$yn" in [yY]*) 

disk_init_par13=$(expr $disk_init_par13 + 1); disk_init_par13=$(printf "%03d\n" $disk_init_par13)

if [ -z "$disk_init_par14" ]; then disk_init_par14="$SYBASE_SID"; disk_init_par12="sapdata_${disk_init_par12}"; fi
disk_init_par1="${disk_init_par14}_data_${disk_init_par13}"
disk_init_par2="/sybase/${SYBASE_SID}/${disk_init_par12}/${disk_init_par1}.dat"  
echo "The next command has been generated:"
disk_init_par20="disk init name=\"${disk_init_par1}\", physname=\"${disk_init_par2}\", skip_alloc=\"${disk_init_par3}\", size=\"${disk_init_par4}M\"${disk_init_par5}${disk_init_par6}${disk_init_par7}${disk_init_par8}${disk_init_par9}${disk_init_par10}${disk_init_par11}"
par00="alter database $par21 on $disk_init_par1 = \"${disk_init_par4}M\""
echo " ${GREEN}$disk_init_par20"
echo " $par00${RESTORE}"

ask_proceed_yn

isql_request_columns_nobold "use master" "$disk_init_par20" "$par00"
tail_rows "4"
echo
isql_request_columns_nobold "use master" "$par01";;
#isql_request_columns_nobold "use master" "select name as DeviceName, phyname as PhysicalLocation from sysdevices where name like "%${par21}%" order by 1";; 
                [nN]*) set_page;;
                *) ;; esac; done
set_page
}

create_new_log_dev_wiz(){
clear
echo "Create new log-device with the wizard"
echo
isql_request_columns_nobold "use master" "sp_helpdevice"
echo
echo "Available databases:"
isql_db_list
echo
par20=$(isql_request "use master" "select name from sysdatabases"); SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"

while [ -z "$par21" ]; do read -p "Enter database name (or 'b' to return back): " par21
                          case "$par21" in b) set_page;;
                                           *) if [[ ! " ${par20[@]} " =~ " ${par21} " ]]; then echo "${RED}WARN: Enter a valid database name!${RESTORE}"; unset par21; continue; 
                                                                                          else break; fi; esac; done; 

echo
#isql_request_columns_nobold "use master" "sp_helpdevice"
echo
par01="select name as DeviceName, phyname as PhysicalLocation from sysdevices where name like \"%${par21}%\" and name not like '%data%' order by 1"
isql_request_columns_nobold "use master" "$par01"
#isql_request_nocolumns_nobold_verbose "use master" "$par01"

echo 
if [ "$par21" == "$SYBASE_SID" ]; then echo "Type the next 5 parameters for a new SAP log-device file:"
  while [ -z "$disk_init_par12" ]; do read -p "1) saplog number N (e.g. /sybase/${SYBASE_SID}/saplog_${GREEN}N${RESTORE}): " disk_init_par12; done
  while [ -z "$disk_init_par13" ]; do read -p "2) device number for ${SYBASE_SID}_log_${GREEN}<Nr.>${RESTORE}, e.g. 002): " disk_init_par13;
  
       if [ ${#disk_init_par13} != 3 ]; then echo "${RED}ERROR: Device number should have only 3 digits!${RESTORE}"; unset disk_init_par13; continue; fi
       if [ "$disk_init_par13" == 000 ]; then echo "${RED}ERROR: Device number cannot be 000!${RESTORE}"; unset disk_init_par13; continue; fi
       disk_init_par1="${SYBASE_SID}_log_${disk_init_par13}"
       disk_init_par2="/sybase/${SYBASE_SID}/saplog_${disk_init_par12}/${disk_init_par1}.dat"
       
       par30=$(isql_request "use master" "select name from sysdevices where name like \"%${par21}%\" and name like '%log%' order by 1"); SAVEIFS="$IFS"; IFS=$'\n'; par30=($par30); IFS="$SAVEIFS"
       if [[ " ${par30[@]} " =~ " ${disk_init_par1} " ]]; then echo "${RED}WARN: Device name already exists in the $SYBASE_SID. Enter a valid device name!${RESTORE}"; unset disk_init_par13; continue; fi 
       
       #for ELEMENT in ${par30[@]}; do echo "$ELEMENT"; done
       
                                                           
       if [ -e "$disk_init_par2" ]; then echo "${RED}ERROR: The data-file already exists: $disk_init_par2${RESTORE}"; unset disk_init_par2; unset disk_init_par13; continue; fi
       if touch "$disk_init_par2" 2>/dev/null; then disk_init_par21=$(df -m "$disk_init_par2" | egrep -v Filesystem | awk '{ print $4 }') 
       echo "INFO: ${GREEN}Free space ${disk_init_par21}MB${RESTORE}"; rm "$disk_init_par2"; break
       else echo "${RED}ERROR: Please check parent directory permissions of the new log file: $disk_init_par2${RESTORE}"; unset disk_init_par13; continue; fi; done
                                    else echo "Type the next 6 parameters for a new SYBASE log-file:"
  while [ -z "$disk_init_par12" ]; do read -p "1) directory name in /sybase/${SYBASE_SID}/, e.g. ${GREEN}$par21${RESTORE}): " disk_init_par12; done
  while [ -z "$disk_init_par14" ]; do read -p "2) file prefix for <${GREEN}$par21${RESTORE}>_log_${disk_init_par13}): " disk_init_par14; done
  while [ -z "$disk_init_par13" ]; do read -p "3) device number for ${par21}_log_${GREEN}<Nr.>${RESTORE}, e.g. 002): " disk_init_par13; 
       if [ ${#disk_init_par13} != 3 ]; then echo "${RED}ERROR: Device number should have only 3 digits!${RESTORE}"; unset disk_init_par13; continue; fi
       if [ "$disk_init_par13" == 000 ]; then echo "${RED}ERROR: Device number cannot be 000!${RESTORE}"; unset disk_init_par13; continue; fi 
       disk_init_par1="${disk_init_par14}_log_${disk_init_par13}"
       disk_init_par2="/sybase/${SYBASE_SID}/${disk_init_par12}/${disk_init_par1}.dat"
       
       par30=$(isql_request "use master" "select name from sysdevices where name like \"%${par21}%\" and name like '%log%'"); SAVEIFS="$IFS"; IFS=$'\n'; par30=($par30); IFS="$SAVEIFS"
       
       #for ELEMENT in ${par30[@]}; do "$ELEMENT"; done
       #echo "for ELEMENT in ${par30[@]}; do "$ELEMENT"; done"
       
       #exit
       if [[ " ${par30[@]} " =~ " ${disk_init_par1} " ]]; then echo "${RED}ERROR: Device name already exists in the $SYBASE_SID. Enter a valid device name!${RESTORE}"; unset disk_init_par13; continue; fi
       if [ -e "$disk_init_par2" ]; then echo "${RED}WARN: The log-file already exists!${RESTORE}"; unset disk_init_par13; continue; fi
       if touch "$disk_init_par2" 2>/dev/null; then disk_init_par21=$(df -m "$disk_init_par2" | egrep -v Filesystem | awk '{ print $4 }') 
       echo "INFO: ${GREEN}Free space ${disk_init_par21}MB${RESTORE}"; rm "$disk_init_par2"; break
       else echo "${RED}ERROR: Please check parent directory permissions of the new log-file: $disk_init_par2${RESTORE}"; unset disk_init_par13; continue; fi; done; fi

while true; do read -p "3) size (in MB). Maximum: 51200MB: " disk_init_par4; 
               if [ "$disk_init_par4" -gt 51200 ]; then echo "${RED}ERROR: Datafile must be not greather then 51200MB${RESTORE}"
                                           else if [ "$disk_init_par4" -gt "$disk_init_par21" ]; then echo "${RED}ERROR: Not enought free space. Maximal size is ${disk_init_par21}MB${RESTORE}"; 
                                                                                                 else break; fi; fi; done

echo                                
echo "The next command has been generated:"
#disk_init_par20="disk init name=\"${disk_init_par1}\", physname=\"${disk_init_par2}\", skip_alloc=\"${disk_init_par3}\", size=\"${disk_init_par4}M\"${disk_init_par5}${disk_init_par6}${disk_init_par7}${disk_init_par8}${disk_init_par9}${disk_init_par10}${disk_init_par11}"
disk_init_par20="disk init name=\"${disk_init_par1}\", physname=\"${disk_init_par2}\", size=\"${disk_init_par4}M\""
par00="alter database $par21 log on $disk_init_par1 = \"${disk_init_par4}M\""
echo " ${GREEN}$disk_init_par20"
echo " $par00${RESTORE}"

ask_proceed_yn

isql_request_columns_nobold "use master" "$disk_init_par20" "$par00"
tail_rows "4" 
echo
echo "Results:"
par01="select name as DeviceName, phyname as PhysicalLocation from sysdevices where name like \"%${par21}%\" and name not like '%data%' order by 1"
isql_request_columns_nobold "use master" "$par01"
set_page
}


create_new_dmp_dev_wiz(){
clear
echo "Adds a dump device to the SAP ASE server."
echo
while true; do read -p "Enter device type (${GREEN}tape${RESTORE} or ${GREEN}disk${RESTORE}) or 'b' to return back): " par01
                    case "$par01" in tape) echo "INFO: The tapesize should be at least five database pages (each page requires 2048 bytes, for this database ${GREEN}$((DB_PAGE_SIZE * 5)) ${RESTORE})."; 
                                           read -p "Enter tape size (in MB): " par04; par04=", $par04"; break;;
                                     disk) break;; 
                                     b) set_page;; esac; done;

read -p "Enter logical name for the device (e.g. mydump): " par02; 

while true; do if [ "$par01" == "disk" ]; then read -p "Enter an absolute or relative path name and file name (e.g. /sybase/${SYBASE_SID}/sapdata_1/${par02}.dat): " par03
                                               #while [ -z "$par01" ] 
                                               if [ -d "$par03" ]; then "${RED}ERROR: The directory is not exists!{RESTORE}"; continue; 
                                                                   else if touch "$par03"; then rm "$par03"; break;  
                                                                                           else echo "${RED}ERROR: Check the permissions of the directory!{RESTORE}"; continue; fi; fi
                                          else read -p "Enter a physical name of the device (e.g. /dev/nrmt8): " par03; break; fi; done                                     

echo "The next command has been generated:"
par00="sp_addumpdevice \"$par01\", $par02, \"$par03\" $par04"
echo " ${GREEN}$par00${RESTORE}"
ask_proceed_yn

isql_request_nocolumns_bold "$par00"

set_page
}

sp_version(){
isql_request_columns_bold "use master" "sp_version"
pause; set_page
}

show_prep_mode(){
isql_request_nocolumns_bold "use master" "select is_prepared(9)"
pause; set_page
}


act_prep_mode(){
clear
#isql_session_b <<EOF
#use master
#go
#sp_autoformat "master.dbo.sysdatabases", "name"
#go
#EOF
echo "Available databases:"
isql_db_list
echo
par20=$(isql_request "use master" "select name from sysdatabases"); SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"

#while [ -z "$par21" ]; do read -p "Enter database name from the list for the Prepare-Mode activation (or 'b' to return back): " par21
#                          if [[ ! " ${par20[@]} " =~ " ${par21} " ]]; then echo "${RED}WARN: Enter a valid database name!${RESTORE}"; unset par21; continue; 
#                                                                      elif [ "$par21" == b ]; then set_page; 
#                                                                      else break; fi; done
                                                                      
while [ -z "$par21" ]; do read -p "Enter database name from the list for the Prepare-Mode activation (or 'b' to return back): " par21
                          case "$par21" in b) set_page;;
                                           *) if [[ ! " ${par20[@]} " =~ " ${par21} " ]]; then echo "${RED}WARN: Enter a valid database name!${RESTORE}"; unset par21; continue; 
                                                                                          else break; fi; esac; done;                                                                       

#while true; do read -p "Type one or more DB names from the list for the Prepare-Mode activation (or 'b' to return back): " db
#			case "$db" in
#		    		b) set_page;;
#		    		*) break;; esac; done;
read -p "Type a tag for the suspending (${CYAN}Hint: Please notice the tag!${RESTORE}): " tag
echo
echo "There are several options for the suspending:"
opt1="prepare database ${tag} hold ${par21} for external dump"			
opt2="prepare database ${tag} hold ${par21} for external dump to <manifest_file>"
opt3="prepare database ${tag} hold ${par21} with overide"
opt4="prepare database ${tag} hold ${par21} with quiesce"
echo "1 - $opt1"
echo "2 - $opt2"
echo "3 - $opt3"
echo "4 - $opt4"
echo "b - back"
while true; do read -p "Select one of it: " answer
      case "$answer" in
		                1) act_com="$opt1"; break;;
                    2) act_com="$opt2"; break;;
                    3) act_com="$opt3"; break;;
                    4) act_com="$opt4"; break;;
                    b) set_page;; esac; done
echo 
echo "The statement has been generated. Make a notice of the tag name '$tag' please: ${GREEN} $act_com ${RESTORE}"
ask_proceed_yn
#while true; do read -p "Proceed? [y/n]: " yn
#        case "$yn" in
#                    y) break;;
#                    n) set_page;; esac; done;

isql_request_columns_bold "use master" "$act_com"
bold_text
tail_rows "1"
pause; set_page
}

deact_prep_mode(){
while true; do read -p "Enter the tag of the current suspending mode (b - back): " tag
      case "$tag" in
		    		b)  set_page;;
		    		*)  break;; esac; done;
echo "Generated statement: ${GREEN}prepare database ${tag} release${RESTORE}"
ask_proceed_yn
#while true; do read -p "Proceed? [y - yes, b - back]: " yn
#      case "$yn" in
#                    y) break;;
#                    n) unset_temp_vars; set_page;; esac; done

par20="prepare database ${tag} release"
isql_request_columns_bold "use master" "$par20"
bold_text
tail_rows "1"

#isql_session <<EOF
#use master
#go
#prepare database ${tag} release
#go
#exit
#EOF
#echo
pause; set_page
}


act_qui_mode(){
echo
echo "Available databases:"
isql_db_list
echo
read -p "Which database should be turn into the Quiesce-Mode: " db_name
string1="quiesce database $SYBASE_SID hold $db_name"
while [ "$yn" != 1 ]; do echo
        echo "The next command will be executed:"
        echo "${GREEN} ${string1} ${RESTORE}"
        read -p "Proceed? [y - yes, e - edit, b - back]: " yn
        case "$yn" in
                    y) yn=1; break;;
                    e) yn=0; read -p "$string1 -> " string1;;
                    b) set_page;; esac; done;

isql_request_columns_bold "use master" "$string1"
bold_text 
tail_rows "1"
pause; set_page
}

deact_qui_mode(){
string1="quiesce database $SYBASE_SID release"
while [ "$yn" != 1 ]; do echo
        echo "The next command will be executed:"
        echo "${GREEN} ${string1} ${RESTORE}"
        read -p "Proceed? [y - yes, e - edit, b - back]: " yn
        case "$yn" in
                    y) yn=1; break;;
                    e) yn=0; read -p "$string1 -> " string1;;
                    b) set_page;; esac; done;

isql_request_columns_bold "use master" "$string1"
bold_text; tail -1 "$alert_log"
pause; set_page
}

isql_table_stats_update(){
clear
echo
while [ "$go" != 1 -o "$accept" != 1 ]; do echo
echo "Put the mandatory parameters for table update statistics:" 
echo "${CYAN}1. Table name*.............................................[$par01]${RESTORE}"
echo "2. Partition name(s).......................................[$par02]"
echo "3. Index name..............................................[$par03] (default: updates all indexes)"
echo "4. Index partition name....................................[$par04] (like IDX_PARTITION_A, IDX_PARTITION_B)"
echo
echo "Generated command(s):"
if [ ! -z "$par02" ]; then par02n="partition $par02";fi
if [ ! -z "$par03" ]; then par04n="$par03";fi
if [ ! -z "$par04" ]; then par04n="partition $par04";fi
par05n="with print_progress = 1"
string1="update table statistics $SAP_SCHEMA.$par01 $par02n $par03n $par04n $par05n"
if [[ -z "$par01" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; else echo " ${GREEN}$string1${RESTORE}"; accept=1; fi
        
echo 
echo "Standard keys (c - continue, r - reset, b - back). " 
read -p "Parameters (1..4): " choice 
case "$choice" in
                    b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars;;
                    1) read -p "Enter table name: " par01;;
                    2) read -p "Enter table partition name(s): " par02;;
                    3) read -p "Enter index name(s): " par03;;
                    4) read -p "Enter index partition name(s): " par04;; esac; done;

par20="use $SYBASE_SID"
isql_request_nocolumns_bold "$par20" "$string1"  
#isql_session <<EOF
#use ${SYBASE_SID}
#go
#${string1}
#go
#exit
#EOF
#echo
pause; set_page
}

isql_table_stats_update_mass(){
echo
echo "Multiple table update statistic"
echo
while [ "$go" != 1 -o "$accept" != 1 ]; do echo
echo "Put the mandatory parameters for table update statistics:" 
echo "${CYAN}1. Table name*.............................................[$par01]${RESTORE}"
echo "2. Partition name(s).......................................[$par02]"
echo "3. Index name..............................................[$par03] (default: updates all indexes)"
echo "4. Index partition name....................................[$par04] (like IDX_PARTITION_A, IDX_PARTITION_B)"
echo

echo "Generated command(s):"
par00n="update statistics"
if [ ! -z "$par02" ]; then par02n="partition $par02";fi
if [ ! -z "$par03" ]; then par04n="$par03";fi
if [ ! -z "$par04" ]; then par04n="partition $par04";fi
par13n="with print_progress = 1"

#string1="update statistics $par01 $par02n $par03n $par04n $par05n $par06n $par07n $par08n $par09n $par10n $par11n $par12n"
if [[ -z "$par01" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; 
else  
par01=$(echo $par01 | tr -d ' ')
delimiter=","
s=$par01$delimiter
arr_tables=();
arr_tables_isql=();
while [[ $s ]]; do arr_tables+=( "${s%%"$delimiter"*}" ); s=${s#*"$delimiter"}; done;
arr_tables_len="${#arr_tables[@]}"
for tbl in "${arr_tables[@]}"; do arr_tables_isql+=( "$par00n $SAP_SCHEMA.$tbl $par13n" ); done
echo "${GREEN}"
for string in "${arr_tables_isql[@]}"; do echo "$string"; done
echo "${RESTORE}"
accept=1
fi
                                   
echo 
echo "Standard keys (c - continue, r - reset, b - back). " 
read -p "Parameters (1..12): " choice 
case "$choice" in
                    b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars;;
                    1) read -p "Enter table list (delimiter comma): " par01;;
                    2) read -p "Enter partition name(s): " par02;;
                    3) read -p "Enter index name(s)" par03;;
                    4) read -p "Enter index partition name(s): " par04;; esac; done;

par20="use $SYBASE_SID"
for string in "${arr_tables_isql[@]}"; do echo "$string"; isql_request_columns_bold "$par20" "$string"; done

#unset_temp_vars
#for string in "${arr_tables_isql[@]}"; do  
#isql_session <<EOF
#use ${SYBASE_SID}
#go
#${string}
#go
#exit
#EOF
#done
pause; set_page
}

isql_all_stats_update(){
clear
while [ "$go" != 1 -o "$accept" != 1 ]; do
echo "Updates all statistics information for a given table, including histograms on all columns, regardless of whether they are indexed:" 
echo "${CYAN}1. Table name*.............................................[$par01]${RESTORE}"
echo "2. Partition name(s).......................................[$par02]"
echo "3. Using step values.......................................[$par03] (default: 20, the number of histogram steps)"
echo "4. Consumers...............................................[$par04] (int, consumer processes to be used for a sort when column_list is provided and parallel query processing is enabled)"
echo "5. Sampling................................................[$par05] (int in %, percentage of the column to be randomly sampled to gather statistics. The value for N is any number between 1 and 100)"
echo "6. Hashing.................................................[$par06] (no_hashing | partial_hashing | hashing) - indicates the level of hash-based statistics update all statistics gathers"
echo "7. Max resource granularity................................[$par07] (default: N, limits the amount of tempdb buffer cache used with the update all statistics and hashing)"
echo "8. Histogram tuning factor.................................[$par08] (int in %, determines update all statistics distribution granularity)"
echo
echo "Generated command(s):"
par00n="update all statistics"
if [ ! -z "$par02" ]; then par02n="partition $par02";fi
if [ ! -z "$par03" ]; then par03n="using step values $par03)";fi
if [ ! -z "$par04" ]; then par04n="with consumers = $par04)";fi
if [ ! -z "$par05" ]; then par05n=", sampling=$par05 percent";fi
if [ ! -z "$par06" ]; then par06n=", $par06)";fi
if [ ! -z "$par07" ]; then par07n=", max_resource_granularity = $par07 percent)";fi
if [ ! -z "$par08" ]; then par08n=", histogram_tuning_factor = $par08)";fi
par09n="with print_progress = 1"
string1="$par00n $SAP_SCHEMA.$par01 $par02n $par03n $par04n $par05n $par06n $par07n $par08n $par09n"
if [[ -z "$par01" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; else echo " ${GREEN}$string1${RESTORE}"; accept=1; fi
        
echo 
echo "Standard keys (c - continue, r - reset, b - back). " 
read -p "Parameters (1...8): " choice 
case "$choice" in
                    b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars;;
                    1) read -p "Enter table name: " par01;;
                    2) read -p "Enter table partition name(s): " par02;;
                    3) read -p "Enter value for 'Using step values': " par03;;
                    4) read -p "Enter value for 'With consumers': " par04;;
                    5) read -p "Enter value for 'Sampling': " par05;;
                    6) read -p "Enter (no_hashing | partial_hashing | hashing): " par06;;
                    7) read -p "Enter value for 'Max resource glanularity': " par07;;
                    8) read -p "Enter value for 'Histogram tuning factor': " par08;; esac; done;

par20="use $SYBASE_SID"
for string in "${arr_tables_isql[@]}"; do isql_request_columns_bold "$par20" "$string"; done

#unset_temp_vars
#isql_session <<EOF
#use ${SYBASE_SID}
#go
#${string1}
#go
#exit
#EOF
pause; set_page
}


isql_all_stats_update_mass(){
echo
echo "Updates all statistics information for given tables, including histograms on all columns, regardless of whether they are indexed."
echo
while [ "$go" != 1 -o "$accept" != 1 ]; do
echo "Updates all statistics information for a given table, including histograms on all columns, regardless of whether they are indexed:" 
echo "${CYAN}1. Table name*.............................................[$par01]${RESTORE}"
echo "2. Partition name(s).......................................[$par02]"
echo "3. Using step values.......................................[$par03] (default: 20, the number of histogram steps)"
echo "4. Consumers...............................................[$par04] (int, consumer processes to be used for a sort when column_list is provided and parallel query processing is enabled)"
echo "5. Sampling................................................[$par05] (int in %, percentage of the column to be randomly sampled to gather statistics. The value for N is any number between 1 and 100)"
echo "6. Hashing.................................................[$par06] (no_hashing | partial_hashing | hashing) - indicates the level of hash-based statistics update all statistics gathers"
echo "7. Max resource granularity................................[$par07] (default: N, limits the amount of tempdb buffer cache used with the update all statistics and hashing)"
echo "8. Histogram tuning factor.................................[$par08] (int in %, determines update all statistics distribution granularity)"
echo
echo "Generated command(s):"
par00n="update all statistics"
if [ ! -z "$par02" ]; then par02n="partition $par02"; fi
if [ ! -z "$par03" ]; then par03n="using step values $par03)"; fi
if [ ! -z "$par04" ]; then par04n="with consumers = $par04)"; fi
if [ ! -z "$par05" ]; then par05n=", sampling=$par05 percent"; fi
if [ ! -z "$par06" ]; then par06n=", $par06)"; fi
if [ ! -z "$par07" ]; then par07n=", max_resource_granularity = $par07 percent)"; fi
if [ ! -z "$par08" ]; then par08n=", histogram_tuning_factor = $par08)"; fi
par09n="with print_progress = 1"
par20="use $SYBASE_SID"

#string1="update statistics $par01 $par02n $par03n $par04n $par05n $par06n $par07n $par08n $par09n $par10n $par11n $par12n"
if [[ -z "$par01" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; else  
par01="$(echo $par01 | tr -d ' ')"
delimiter=","
s="$par01$delimiter"
arr_tables=();
arr_tables_isql=();
while [[ $s ]]; do arr_tables+=( "${s%%"$delimiter"*}" ); s=${s#*"$delimiter"}; done;
arr_tables_len="${#arr_tables[@]}"
for tbl in "${arr_tables[@]}"; do arr_tables_isql+=( "$par00n $SAP_SCHEMA.$tbl $par09n" ); done
echo "${GREEN} $par20"
for string in "${arr_tables_isql[@]}"; do echo " $string"; done
echo "${RESTORE}"
accept=1; fi
                                           
echo 
echo "Standard keys (c - continue, r - reset, b - back). " 
read -p "Parameters (1..12): " choice 
case "$choice" in
                    b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars;;
                    1) read -p "Enter table name: " par01;;
                    2) read -p "Enter table partition name(s): " par02;;
                    3) read -p "Enter value for 'Using step values': " par03;;
                    4) read -p "Enter value for 'With consumers': " par04;;
                    5) read -p "Enter value for 'Sampling': " par05;;
                    6) read -p "Enter (no_hashing | partial_hashing | hashing): " par06;;
                    7) read -p "Enter value for 'Max resource glanularity': " par07;;
                    8) read -p "Enter value for 'Histogram tuning factor': " par08;; esac; done

for string in "${arr_tables_isql[@]}"; do isql_request_columns_bold "$par20" "$string"; done
pause; set_page
}

isq_stats_update(){
echo
echo "Updates information about the distribution of key values in specified indexes, for all columns in an index, table, or partition, and resets the data change counters for global nonclustered indexes."
echo
while [ "$go" != 1 -o "$accept" != 1 ]; do echo
echo "Updates all statistics information for a given table, including histograms on all columns, regardless of whether they are indexed:" 
echo "${CYAN}1. Table name*.............................................[$par01]${RESTORE}"
echo "2. Partition name(s).......................................[$par02]"
echo "3. Column(s)...............................................[$par03] (like COLUMN_A, COLUMN_B)"
echo "4. Index name..............................................[$par04] (default: updates all indexes)"
echo "5. Index partition name....................................[$par05] (like IDX_PARTITION_A, IDX_PARTITION_B)"
echo "6. Using step values.......................................[$par06] (default: 20)"
echo "7. Out of range............................................[$par07] (default | on | off)"
echo "8. Consumers...............................................[$par08] (int)"
echo "9. Sampling................................................[$par09] (int in %)"
echo "10. Hashing................................................[$par10] (no_hashing | partial_hashing | hashing)"
echo "11. Max resource granularity...............................[$par11] (N)"
echo "12. Histogram tuning factor................................[$par12] (int in %)"
echo 
echo "Generated command(s):"
if [ ! -z "$par02" ]; then par02n="partition $par02";fi
if [ ! -z "$par03" ]; then par03n="($par03)";fi
if [ ! -z "$par04" ]; then par04n="$par04";fi
if [ ! -z "$par05" ]; then par05n="partition $par05";fi
if [ ! -z "$par06" ]; then par06n="using step values $par06)";fi
if [ ! -z "$par07" ]; then par07n="ouf_of_range = $par07)";fi
if [ ! -z "$par08" ]; then par08n="with consumers = $par08)";fi
if [ ! -z "$par09" ]; then par09n=", sampling=$par09 percent";fi
if [ ! -z "$par10" ]; then par10n=", $par10)";fi
if [ ! -z "$par11" ]; then par11n=", max_resource_granularity = $par11 percent)";fi
if [ ! -z "$par12" ]; then par12n=", histogram_tuning_factor = $par12)";fi
par20="use $SYBASE_SID"
par13n="with print_progress = 1"
par00n="$par02n $par03n $par04n $par05n $par06n $par07n $par08n $par09n $par10n $par11n $par12n $par13n"
#if [[ -z "$par01" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; else echo " ${GREEN}$string1${RESTORE}"; accept=1; fi
if [[ -z "$par01" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; 
else  
par01=$(echo $par01 | tr -d ' ')
delimiter=","
s=$par01$delimiter
arr_tables=();
arr_tables_isql=();
while [[ $s ]]; do arr_tables+=( "${s%%"$delimiter"*}" ); s=${s#*"$delimiter"}; done;
arr_tables_len="${#arr_tables[@]}"
#for tbl in "${arr_tables[@]}"; do arr_tables_isql+=( "$par00n $SAP_SCHEMA.$tbl" ); done
for tbl in "${arr_tables[@]}"; do arr_tables_isql+=( "update all statistics $SAP_SCHEMA.$tbl $par00n" ); done
echo "${GREEN}"
echo " $par20"
for string in "${arr_tables_isql[@]}"; do echo " $string"; done
echo "${RESTORE}"
accept=1
fi
        
echo 
echo "Standard keys (c - continue, r - reset, b - back). " 
read -p "Parameters (1...12): " choice 
case "$choice" in
                    b) unset par01; set_page;;
                    c) go=1;;
                    r) unset_temp_vars;;
                    1) read -p "Enter table name: " par01;;
                    2) read -p "Enter table partition name(s): " par02;;
                    3) read -p "Enter column name(s): " par03;;
                    4) read -p "Enter index partition name(s): " par04;;
                    5) read -p "Enter number of histogram steps (default: 20) : " par05;;
                    6) read -p "Enter " par06;;
                    7) read -p "" par07;;
                    8) read -p "" par08;;
                    9) read -p "" par09;;
                    10) read -p "" par10;;
                    11) read -p "" par11;;
                    12) read -p "" par12;; esac; done;

for string in "${arr_tables_isql[@]}"; do isql_request_nocolumns_bold "$par20" "$string"; done
pause; set_page
}

isql_idx_stats_update(){
echo
echo "Updates the statistics for all columns in an index."
echo
while [ "$go" != 1 -o "$accept" != 1 ]; do echo
echo "Put the requirement parameters for table update statistics:" 
echo "${CYAN}1. Table name*.............................................[$par01]${RESTORE}"
echo "2. Partition name(s).......................................[$par02]"
echo "3. Index name..............................................[$par03] (default: updates all indexes)"
echo "4. Index partition name....................................[$par04] (like IDX_PARTITION_A, IDX_PARTITION_B)"
echo "5. Using step values.......................................[$par05] (default: 20)"
echo "6. Consumers...............................................[$par06] (int)"
echo "7. Sampling................................................[$par07] (int in %)"
echo "8. Hashing.................................................[$par08] (no_hashing | partial_hashing | hashing)"
echo "9. Max resource granularity................................[$par09] (N)"
echo "10. Histogram tuning factor................................[$par10] (int in %)"
echo

par00n="update index statistics"
if [ ! -z "$par02" ]; then par02n=" partition $par02"; else par02n="";fi
if [ ! -z "$par03" ]; then par03n=" \"$par03\""; else pa03n=""; fi
if [ ! -z "$par04" ]; then par04n=" partition $par04"; else par04n="";fi
if [ ! -z "$par05" ]; then par05n=" using step values $par05)";else par05n="";fi
if [ ! -z "$par06" ]; then par06n=" with consumers =  $par06)";else par06n="";fi
if [ ! -z "$par07" ]; then par07n=", sampling=$par07 percent";else par07n="";fi
if [ ! -z "$par08" ]; then par08n=", $par08";else par08n="";fi
if [ ! -z "$par09" ]; then par09n=", max_resource_granularity = $par09 percent)"; else par09n="";fi
if [ ! -z "$par10" ]; then par10n=", histogram_tuning_factor = $par10)";else par10n="";fi
par11n=" with print_progress = 1"
#string1="update statistics $par01 $par02n $par03n $par04n $par05n $par06n $par07n $par08n $par09n $par10n $par11n $par12n"
if [[ -z "$par01" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; 
else  
par01=$(echo $par01 | tr -d ' ')
delimiter=","
s=$par01$delimiter
arr_tables=();                                                                                  
arr_tables_isql=();
while [[ $s ]]; do arr_tables+=( "${s%%"$delimiter"*}" ); s=${s#*"$delimiter"}; done;
arr_tables_len="${#arr_tables[@]}"
for tbl in "${arr_tables[@]}"; do arr_tables_isql+=( "$par00n $SAP_SCHEMA.\"$tbl\"$par02n$par03n$par04n$par05n$par06n$par07n$par08n$par09n$par10n$par11n" ); done
accept=1
menu_separator

echo "The table ${par01} has the next indexes:"
isql_session_b <<EOF
SET NOCOUNT ON
use ${SYBASE_SID}
go
select i.name from sysindexes i, sysobjects o where o.name = '${par01}' and o.id = i.id
go
exit
EOF
menu_separator
echo "Generated command(s):${GREEN}"
par20="use $SYBASE_SID"
par21="set quoted_identifier on"
echo " $par20"
echo " $par21"
for string in "${arr_tables_isql[@]}"; do echo " $string"; done
fi
echo "${RESTORE}"
 
echo "Standard keys (c - continue, r - reset, b - back). " 
read -p "Parameters (1..12): " choice 
case "$choice" in
                    b) unset par01; set_page;;
                    c) go=1;;
                    r) unset_temp_vars;; 
                    1) read -p "Table name: " par01;;
                    2) read -p "" par02;;
                    3) read -p "" par03;;
                    4) read -p "" par04;;
                    5) read -p "" par05;;
                    6) read -p "" par06;;
                    7) read -p "" par07;;
                    8) read -p "" par08;;
                    9) read -p "" par09;;
                    10) read -p "" par10;; esac; done;

for string in "${arr_tables_isql[@]}"; do isql_request_columns_bold "$par20" "$par21" "$string"; done
pause; set_page
}


isql_idx_stats_update_mass(){
echo "Update index statisctic for all tables. It takes a lot of time!!!"

ask_proceed_yn
isql_session <<EOF
use @@servername
go

set nocount on
go

declare c_systabs cursor for select so.name from sysobjects so
where so.type='S' and so.name not in ('syslogs','sysgams','sysdams','sysencryptkeys','sysroles')
go

declare @systablename longsysname, @cmd varchar(511)
open c_systabs
fetch c_systabs into @systablename

while (@@sqlstatus = 0)
begin
  set @cmd = "update index statistics [" || @systablename || "]"
  print "Executing '%1!'", @cmd
  exec (@cmd)
  fetch c_systabs into @systablename
end

close c_systabs
go
deallocate cursor c_systabs
go

declare c_tablename cursor for select so.name, user_name(so.uid) from sysobjects so
where so.type ='U' and
so.name not in ('VBDATA','VBHDR','VBMOD','ARFCRSTATE','ARFCSDATA',
'ARFCSSTATE','QREFTID','TRFCQDATA','TRFCQIN','TRFCQINS','TRFCQSTATE')
go

declare @tablename longsysname, @owner sysname, @cmd varchar(511)
open c_tablename
fetch c_tablename into @tablename, @owner

while (@@sqlstatus = 0)
begin
  set @cmd = "update index statistics " || @owner || ".[" || @tablename || "]"
  print "Executing '%1!'", @cmd
  exec (@cmd)
  fetch c_tablename into @tablename,@owner
end

close c_tablename
go
deallocate cursor c_tablename
go
exit
EOF
pause; set_page
}


isql_table_stats_del_mass(){
clear
echo
echo "Deletes the densities, selectivities, and histograms for all columns in a table."
echo
read -p "Enter a table name or multiple tables (delimiter: comma): " par01
if [[ -z "$par01" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; 
else  
par01=$(echo $par01 | tr -d ' ')
par20="use $SYBASE_SID"
delimiter=","
s=$par01$delimiter
arr_tables=();
arr_tables_isql=();
while [[ $s ]]; do arr_tables+=( "${s%%"$delimiter"*}" ); s=${s#*"$delimiter"}; done;
arr_tables_len="${#arr_tables[@]}"
for tbl in "${arr_tables[@]}"; do arr_tables_isql+=( "delete statistics $SAP_SCHEMA.$tbl" ); done
echo "The next command will be executed:"
echo "${GREEN}"
echo " $par20"
for string in "${arr_tables_isql[@]}"; do echo " $string"; done
echo "${RESTORE}"
accept=1
fi

ask_proceed_yn
for string in "${arr_tables_isql[@]}"; do isql_request_columns_bold "$par20" "$string"; done
pause; set_page
}


isql_table_stats_del(){
echo
echo "Removes statistics from the sysstatistics system table."
echo 
while [ "$go" != 1 -o "$accept" != 1 ]; do echo
echo "${CYAN}1. Table name*.............................................[$par01]${RESTORE}"
echo "2. Partition name(s).......................................[$par02]"
echo "3. Column(s)...............................................[$par03] (like COLUMN_A, COLUMN_B)"
echo

echo "Generated command(s):"
par00n="delete statistics"
if [ ! -z "$par02" ]; then par02n="partition $par02";fi
if [ ! -z "$par03" ]; then par03n="($par03)";fi
#par04n="with print_progress = 1"
par20="use $SYBASE_SID"

if [[ -z "$par01" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; 
else  
par01=$(echo $par01 | tr -d ' ')
delimiter=","
s=$par01$delimiter
arr_tables=(); arr_tables_isql=();
while [[ $s ]]; do arr_tables+=( "${s%%"$delimiter"*}" ); s=${s#*"$delimiter"}; done;
arr_tables_len="${#arr_tables[@]}"
for tbl in "${arr_tables[@]}"; do arr_tables_isql+=( "$par00n $SAP_SCHEMA.$par01 $par02n $par03n" ); done
echo "${GREEN}" 
echo " $par20"
for string in "${arr_tables_isql[@]}"; do echo "$string"; done
accept=1
fi
echo "${RESTORE}"
                                   
echo 
echo 'Standard keys (c - continue, r - reset, b - back)'
read -p "Parameters (1..3): " choice 
case "$choice" in
                    b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars;;
                    1) read -p "Enter table name: " par01;;
                    2) read -p "Enter table partition name(s): " par02;;
                    3) read -p "Enter column name(s): " par03;; esac; done

for string in "${arr_tables_isql[@]}"; do isql_request_columns_bold "$par20" "$string"; done
pause; set_page
}


isql_idx_reorg(){
clear
echo
echo "Running rebuild on indexes"
echo "reorg rebuild ... online includes three phases:"
echo " - A blocking phase that takes exclusive table locks for a short duration to set up new metadata"
echo " - A nonblocking phase that reorganizes the data and synchronizes the concurrent activity"
echo " - A blocking phase that reacquires exclusive table locks to synchronize the remaining concurrent activity and install the new metadata"
echo
#default values: 
par00n="reorg rebuild"
par19="set quoted_identifier on"
par20="use $SYBASE_SID"

while [ "$go" != 1 -o "$accept" != 1 ]; do echo
echo "${CYAN}1. Table name*(s)..............................................[$par01]${RESTORE}"
echo "2. With online.................................................[$par02] (Default: yes)"
echo
echo "Generated commands:"

if [ -z "$par02" ] || [ "$par02" == "yes" ]; then par02n="with online"; elif [ "$par02" == "no" ]; then par02n=""; else par02n=""; fi

if [[ -z "$par01" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; 
else  
par01=$(echo $par01 | tr -d ' ')
delimiter=","
s=$par01$delimiter
arr_tables=(); arr_tables_isql=();
while [[ $s ]]; do arr_tables+=( "${s%%"$delimiter"*}" ); s=${s#*"$delimiter"}; done;
arr_tables_len="${#arr_tables[@]}"
for tbl in "${arr_tables[@]}"; do arr_tables_isql+=( "$par00n $SAP_SCHEMA.\"$tbl\" $par02n" ); done
echo "${GREEN}"
echo " $par19"
echo " $par20"
for string in "${arr_tables_isql[@]}"; do echo " $string" ; done
accept=1
fi
echo "${RESTORE}"
                                   
echo 
echo "Standard keys (c - continue, r - reset, b - back)." 
read -p "Parameters (1..2): " choice 
case "$choice" in
                    b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars;;
                    1) read -p "Enter table name or a list of multiple tables(delimiter: comma): " par01;;
                    2) read -p "Online rebuild? [yes] or [no]: " par02;; esac; done


for string in "${arr_tables_isql[@]}"; do isql_request_columns_bold "$par19" "$par20" "$string"; done
pause; set_page
}



isql_table_reorg_mass(){
echo
echo "Running reorg on table(s)."
echo "The reorg command can improve performance for data-only-locked tables by improving the space utilization for tables."
echo
#default values: 
par00="reorg"
par03="with online"
par04="rebuild"
par20="use $SYBASE_SID"
par21="set quoted_identifier on"



while [ "$go" != 1 -o "$accept" != 1 ]; do
if [ ! -z "$par02" ]; then par02n="partition $par02"; fi
if [ ! -z "$par03" ]; then par03n="$par03"; fi
if [ "$par04" == "rebuild" ]; then par03="with online"; par03n="with online"; else par03="${RED}*offline*${RESTORE}"; par03n=""; par04n="$par04"; fi
echo
echo "${CYAN}1. Table name*(s)..............................................[$par01]${RESTORE}"
echo "2. Partition name(s)...........................................[$par02] (Default: all table partitions)"
echo "3. Mode: online / offline......................................[$par03]"
echo "4. Reorganization levels.......................................[$par04]"
echo "      [rebuild]        - rebuilds an entire table (online/offline)"
echo "      [defrag]         - reorganizes each partition list or partition in the table (offline)"
echo "      [reclaim_space]  - clears committed deletes and space left when updates shorten the length of data rows(offline)"
echo "      [forwarded_rows] - returns forwarded rows to home pages (offline)"
echo "      [compact]        - performs both of the operations above (offline)"
echo
echo "Generated command(s):"


#if [ "$par04" == "rebuild" ]; then par03="with online"; par03n="with online"; else par03="*offline*"; par03n=""; par04n="$par04"; fi

if [[ -z "$par01" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; 
else  
par01=$(echo $par01 | tr -d ' ')
delimiter=","
s=$par01$delimiter
arr_tables=(); arr_tables_isql=();
while [[ $s ]]; do arr_tables+=( "${s%%"$delimiter"*}" ); s=${s#*"$delimiter"}; done;
arr_tables_len="${#arr_tables[@]}"
for tbl in "${arr_tables[@]}"; do arr_tables_isql+=( "$par00 $par04 $SAP_SCHEMA.\"$tbl\" $par03n" ); done
echo "${GREEN} $par20"
echo " $par21"
for string in "${arr_tables_isql[@]}"; do echo " $string"; done
accept=1
fi
echo "${RESTORE}"                                   
 
echo "Standard keys (c - continue, r - reset, b - back)." 
read -p "Parameters (1..4): " choice 
case "$choice" in
                    b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars;;
                    1) read -p "Enter table name or a list of multiple tables(delimiter: comma): " par01;;
                    2) read -p "Enter partition of a table: " par02;;
                    3) read -p "Enter mode: " par03;;
                    4) read -p "Enter reorganizational level: " par04;; esac; done

for string in "${arr_tables_isql[@]}"; do isql_request_columns_bold "$par21" "$par20" "$string"; done
pause; set_page
}

dbcc_checktable(){
clear
echo "The dbcc checktable checks the specified table to see that:"
echo "- Index and data pages are linked correctly"
echo "- Indexes are sorted properly"
echo "- Pointers are consistent"
echo "- All indexes and data partitions are correctly linked"
echo "- Data rows on each page have entries in the row-offset table; these entries match the locations for the data rows on the page"
echo "- Partition statistics for partitioned tables are correct"
while [ "$go" != 1 -o "$accept" != 1 ]; do echo
echo "${CYAN}1. Table name(s)*..........................................[$par02]${RESTORE}"
echo "2. Partition name(s).......................................[$par03]"
echo

echo "Generated command(s):"
CUR_SAP_SCHEMA="\"${SAP_SCHEMA}\""
par20="use $SYBASE_SID"
par22="setuser $CUR_SAP_SCHEMA"
par21="set quoted_identifier on"
par00n="dbcc checktable"
par01n="('"
par04n="')"

if [ -z "$par03" ]; then par03n=""; else par03n=", NULL, \"$par03\"";fi
if [[ -z "$par02" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; 
else par02=$(echo $par02 | tr -d ' '); delimiter=","; s=$par02$delimiter; arr_tables=(); arr_tables_isql=();
while [[ $s ]]; do arr_tables+=( "${s%%"$delimiter"*}" ); s=${s#*"$delimiter"}; done;
arr_tables_len="${#arr_tables[@]}"
for tbl in "${arr_tables[@]}"; do arr_tables_isql+=( "$par00n $par01n$tbl$par03n$par04n" ); done

echo "${GREEN}"
echo " $par20"
echo " $par22"
echo " $par21"
for string in "${arr_tables_isql[@]}"; do echo " $string"; done
echo "${RESTORE}"
accept=1; fi
                                   
echo "Standard keys (c - continue, r - reset, b - back)." 
read -p "Parameters (1..2): " choice 
case "$choice" in
                    b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars;;
                    1) read -p "Enter table name(s): " par02;;
                    2) read -p "Enter partition name(s): " par03;; esac; done;




for string in "${arr_tables_isql[@]}"; do isql_request_columns_bold "$par20" "$par22" "$par21" "$string"; done

pause; set_page
}



isql_db_list(){
#isql_session_b <<EOF
#SET NOCOUNT ON
#SET PROC_RETURN_STATUS OFF
#go
#select name from master..sysdatabases
#go
#exit
#EOF
#echo
isql_request_nocolumns_nobold "use master" "select name from master..sysdatabases"
}

dbcc_checkdb(){
clear
echo "The dbcc checkdb runs the same checks as dbcc checktable on each table in the specified database"
echo
#default values: 
par00="dbcc checkdb"
par01=""
            
echo "Available databases:"
isql_db_list

while [ "$go" != 1 -o "$accept" != 1 ]; do echo
echo "${CYAN}1. Database name(s)*..............................................[$par01]${RESTORE} (Values: 'all' or enter database names with delimiter ',')"
echo
echo "Generated command(s):"
if [ -z "$par01" ]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; 
  elif [ "$par01" = "all" ]; then count=0
        DB_LIST=$(isql_db_list) ; DB_LIST="${DB_LIST//[[:blank:]]/}"   
        SAVEIFS="$IFS"; IFS=$'\n'; DB_LIST=($DB_LIST); IFS="$SAVEIFS"
        #for i in "${DB_LIST[@]}"; do echo $i ; done
        for i in "${DB_LIST[@]}"; do DB_LIST[$count]=" $par00 ($i) "; count=$((count + 1)); done
        for i in "${DB_LIST[@]}"; do echo "${GREEN}$i ${RESTORE}"; accept=1; done
  elif [ ! -z "$par01" ] && [ "$par01" != "all" ]; then count=0 
        SAVEIFS="$IFS"; IFS=$','; DB_LIST=($par01) ; IFS="$SAVEIFS"; 
        for i in "${DB_LIST[@]}"; do DB_LIST[$count]=" $par00 ($i)"; count=$((count + 1)); done
        for i in "${DB_LIST[@]}"; do echo "${GREEN}$i ${RESTORE}"; accept=1; done; fi
echo 
echo "Standard keys (c - continue, r - reset, b - back)." 
read -p "Parameter [1]: " choice 
case "$choice" in
                    b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars;;
                    1) read -p "Enter database name(s) with delimiter ','): " par01;; esac; done;

for i in "${DB_LIST[@]}"; do isql_request_nocolumns_bold "$i"; done
pause; set_page
}

dbcc_checkverify(){
clear
echo "DBCC checkverify"
echo "Available databases:"
isql_db_list
echo
par20=$(isql_request "use master" "select name from sysdatabases"); SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"

while [ -z "$par01" ]; do read -p "Enter database name (or 'b' to return back): " par01
                          case "$par01" in b) set_page;;
                                           *) if [[ ! " ${par20[@]} " =~ " ${par01} " ]]; then echo "${RED}WARN: Enter a valid database name!${RESTORE}"; unset par01; continue; 
                                                                                          else break; fi; esac; done; 


while [ "$go" != 1 -o "$accept" != 1 ]; do echo
echo "1. Database name...............................................[$par01]"
echo "${CYAN}2. Table name(s)*..............................................[$par02]${RESTORE} (Values: single or multiple table names with delimiter ',')"
echo
echo "Generated command(s):"
if [ -z "$par02" ]; then echo "${RED}!!!Provide all ${CYAN}cyan${RED} mandatory field!!!${RESTORE}"; unset array00; 
                    else if [ ${#array00[@]} -eq 0 ]; then par02=$(echo $par02 | tr -d ' '); delimiter=","; s=$par02$delimiter; arr_tables=(); #arr_tables_isql=();
                                                           while [[ $s ]]; do arr_tables+=( "${s%%"$delimiter"*}" ); s=${s#*"$delimiter"}; done;
                                                           for i in "${arr_tables[@]}"; do array00+=( "dbcc checkverify($par01, $i)" ); done
                                                           for i in "${array00[@]}"; do echo " ${GREEN}$i${RESTORE}"; accept=1; done; fi; fi
echo 
echo "Standard keys (c - continue, r - reset, b - back)." 
read -p "Parameter [2]: " choice 
case "$choice" in   b) set_page;;
                    c) go=1;;
                    r) unset par02; unset array00;;
                    2) read -p "Enter table name(s) with delimiter ',': " par02;; esac; done;

for i in "${array00[@]}"; do isql_request_nocolumns_bold "$i"; done
 
pause; set_page
}

dbcc_checkstorage(){
clear
echo "The DBCC CHECKSTORAGE checks:"
echo "- Allocation of text valued columns"
echo "- Page allocation and consistency"
echo "- OAM page entries"
echo "- An OAM page for each partition exists"
echo "- Pointer consistency"
echo "- Text-valued columns and text-column chains"
pause; set_page
}


dbcc_checkstorage_createdb(){
clear
echo
echo "Build the DBCDB Database:"
echo "- Before you can run the DBCC CHECKSTORAGE utility, you must first create the dbccdb database. This database is used exclusively for the CHECKSTORAGE utility, and is not created as part of the default ASE installation."
echo "- Although procedures for creating the dbccdb database are contained in greater detail within the ASE manuals, the purpose of this document is to provide a step-by-step guide on how to create and configure a dbccdb database."
echo "- This document assumes you do not have a dbccdb database and are performing these steps using the 'sa' login (or with an ASE account with dba authority)."
echo
echo "The creating DBCCDB contains the next steps:"
echo "1. Estimate DBCCDB-Requirements."
echo "2. Decide on a Method of Running DBCC Checks: Serially or Concurrently."
echo "3. Build the DBCC Database."
echo "4. Create the Work Segments."
echo "5. Create System DBCCDB-Tables and Initialize the DBCC Types Table."
echo "6. Set the Recommended Configuration Parameters."

ask_proceed_yn

echo "Step 1 --- Getting Started:  Estimate Your Requirements"
isql_request_nocolumns_nobold "use master" "execute sp_plan_dbccdb"

echo "Step 2 --- Decide on a Method of Running DBCC Checks"
echo "Decide on a Method of Running DBCC Checks: Serially or Concurrently."

echo "Step 3 --- Build the dbccdb Database:"
# Ask about data device:
read -p "Enter the ${BOLD}data device name${RESTORE}(e.g. dbccdb_data): " par00
while true; do read -p "Enter the ${BOLD}destination data device/file${RESTORE} (e.g. ${SYBASE}/dbccdb/dbccdb_data.dat ): " par01
               read -p "Enter the ${BOLD}data device/file size ${RESTORE}(in MB): " par03
if [ ! -e $par01 ]; then if touch $par01; then par02=$(df -m $par01 | egrep -v Filesystem | awk '{ print $4 }'); rm $par01;
                         if (( "$par02" > "$par03" )); then break; 
                         else echo "ERROR: Filesystem is too small for the file"; continue; fi;
      else echo "ERROR: No permissions to create the file or the directory does not exist"; continue; fi 
else echo "ERROR: File already exists (Delete device manually: sp_dropdevice & rm)"; continue; fi; done  

# Ask about log device:
read -p "Enter the ${BOLD}log device name${RESTORE}(e.g. dbccdb_log): " par00n
while true; do read -p "Enter the ${BOLD}destination log device/file${RESTORE} (e.g. ${SYBASE}/dbccdb/dbccdb_log.dat): " par01n
               read -p "Enter the ${BOLD}log device/file size ${RESTORE}(in MB): " par03n
if [ ! -e $par01n ]; then if touch $par01n; then par02n=$(df -m $par01n | egrep -v Filesystem | awk '{ print $4 }'); rm $par01n;
                         if (( "$par02n" > "$par03n" )); then break; 
                         else echo "ERROR: Filesystem is too small for the file"; continue; fi;
      else echo "ERROR: No permissions to create the file or the directory does not exist"; continue; fi 
else echo "ERROR: File already exists (Delete device manually: sp_dropdevice & rm)"; continue; fi; done

par04="disk init name = \"${par00}\", physname = \"${par01}\", size = \"${par03}M\""
par05="disk init name = \"${par00n}\", physname = \"${par01n}\", size = \"${par03n}M\""
par06="create database dbccdb on $par00 = $par03 log on $par00n = $par03n"

echo "The next SQL-commands have been generated:"
echo "${GREEN}"
echo " $par04"
echo " $par05"
echo " $par06"
echo "${RESTORE}"

ask_proceed_yn
 
isql_request_nocolumns_bold "use master" "$par04" "$par05" "$par06" 

echo "Step 4 --- Create the Work Segments:"
par10="use dbccdb"
par11="execute sp_addsegment scanseg, dbccdb, $par00"
par12="sp_addsegment textseg, dbccdb, $par00"
echo "The next SQL-commands have been generated:"
echo "${GREEN}"
echo " $par10"
echo " $par11"
echo " $par12"
echo "${RESTORE}"

ask_proceed_yn
isql_request_nocolumns_bold "$par10" "$par11" "$par12"
 

echo "Step 5 --- Create System Tables for the DBCCDB and Initialize the DBCC Types Table:"

if [ -z "$SA_PASSWD" ]; then isql_passwd_check; fi

echo "The next OS-command has been generated:"
par13="isql -Usa -P${SA_PASSWD} -iinstalldbccdb"
echo "${GREEN}$par13${RESTORE}"
ask_proceed_yn

echo "Step 6 --- Set the Recommended Configuration Parameters:"
ask_proceed_yn
isql_request_nocolumns_bold "use master" "sp_plan_dbccdb"

pause; set_page
}


dbcc_checkalloc(){
clear
echo
echo "Detect allocation errors within a database"
echo
#default values: 
par00="dbcc checkalloc"
par01=""
par02="nofix"
            
echo "Available databases:"
isql_db_list

while [ "$go" != 1 -o "$accept" != 1 ]; do echo
echo "${CYAN}1. Database name(s)*..............................................[$par01]${RESTORE} (Values: 'all' - check all databases; or enter database name(s) with delimiter ',')"
echo "2. Fix option.....................................................[$par02] (Default: 'nofix'; 'fix': correct any allocation errors encountered)"

echo
echo "Generated command(s):"
if [ -z "$par02" ]; then par02="nofix"; elif [ "$par02" = "fix" ]; then par02="fix"; else par02=nofix; fi 

if [ -z "$par01" ]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; 
  elif [ "$par01" = "all" ]; then count=0
        DB_LIST=$(isql_db_list) ; DB_LIST="${DB_LIST//[[:blank:]]/}"   
        SAVEIFS="$IFS"; IFS=$'\n'; DB_LIST=($DB_LIST); IFS="$SAVEIFS"
        for i in "${DB_LIST[@]}"; do echo $i ; done
        for i in "${DB_LIST[@]}"; do DB_LIST[$count]=" $par00 ($i,$par02)"; count=$((count + 1)); done
        for i in "${DB_LIST[@]}"; do echo "${GREEN}$i ${RESTORE}"; accept=1; done
  elif [ ! -z "$par01" ] && [ "$par01" != "all" ]; then count=0 
        SAVEIFS="$IFS"; IFS=$','; DB_LIST=($par01) ; IFS="$SAVEIFS"; 
        for i in "${DB_LIST[@]}"; do DB_LIST[$count]=" $par00 ($i,$par02)"; count=$((count + 1)); done
        for i in "${DB_LIST[@]}"; do echo "${GREEN} $i${RESTORE}"; accept=1; done; fi
echo 
echo "Standard keys (c - continue, r - reset, b - back)." 
read -p "Parameter (1..2): " choice 
case "$choice" in   b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars;;
                    1) read -p "Enter database name(s) with delimiter ','): " par01;;
                    2) read -p "Enter option ('fix' or 'nofix'): " par02;; esac; done;

for string in "${DB_LIST[@]}"; do isql_request_nocolumns_bold "$string"; done
pause; set_page
}

dbcc_indexalloc(){
clear
echo
echo "The dbcc indexalloc checks the specified index to see that:"
echo "- All pages are correctly allocated"
echo "- No page is allocated that is not used"
echo "- No page is used that is not allocated."
echo

#default values: 
par00="DBCC INDEXALLOC"
par03="NOFIX"
par04="OPTIMIZED"
#CUR_SAP_SCHEMA="\"${SAP_SCHEMA}\""
CUR_SAP_SCHEMA="${SAP_SCHEMA}"
par23="set quoted_identifier on"            
par20="use ${SYBASE_SID}"
par21="setuser \"${CUR_SAP_SCHEMA}\""
count=0
while [ "$go" != 1 -o "$accept" != 1 -o "$accept2" != 1 ]; do echo 
if [ ! -z "$par01" ]; then echo "The table $par01 has the next indexes and indexes ID:"
par22="SELECT convert(varchar(30),o.name) as TableName, convert(varchar(30),i.name) as IndexName, i.indid as IndexID FROM sysobjects o JOIN sysindexes i ON (o.id = i.id) WHERE o.name = \"$par01\""
isql_request_nocolumns_bold "$par20" "$par21" "$par22" ; fi



if [ "$par03" = "FIX" ]; then par03n=", FIX"; 
    elif [ "$par03" = "NOFIX" ]; then par03n=", NOFIX"; 
    else par03="${RED}!!!Please select: FIX or NOFIX!!!${RESTORE}"; fi

if [ "$par04" = "OPTIMIZED" ]; then par04n=", $par04";
     elif [ "$par04" = "FULL" ] || [ "$par04" = "FAST" ] || [ "$par04" = "NOREPORT" ]; then par04n=", $par04"
     #elif [ "$par04" = "FULL" ]; then par04n=", $par04"    
     else par04="${RED}!!!Please select a valid report type!!!${RESTORE}"; fi
echo
echo "${CYAN}1. Table name*..............................................[$par01]${RESTORE}"
echo "${CYAN}2. Index ID*................................................[$par02]${RESTORE}"
echo "3. Fix option...............................................[$par03] (Default: 'NOFIX'; 'FIX': correct any allocation errors encountered)"
echo "4. Report type..............................................[$par04] (Default: OPTIMIZED)"
echo "	- OPTIMIZED (Reflects those allocation pages that were listed in the object's OAM pages. Some 2540 errors may get missed by this report, if the information in the OAM pages is not accurate)"
echo "	- FULL (It reports all allocation errors that may exist in the table/index. It scans all allocation pages in the database to find extents allocated to the object requested)"
echo "	- FAST (This mode does not generate an allocation report, therefore it executes faster. The 2521 errors, if encountered in this report, may get corrected with the fix type of 'FIX')"
echo "                   This is the fastest way of correcting 2521)"
echo "	- NOREPORT (Similar to FAST, but it does not correct 2521 errors." 
echo "                   This mode does not deal with initializing the diagnostic bitmaps and expects a higher module to initialize all the bitmaps in all allocation pages)"
#DBCC INDEXALLOC ('BALDAT', 0, OPTIMIZED, NOFIX)
#DBCC INDEXALLOC ('BALDAT', OPTIMIZED, NOFIX)
#echo "count= $count"
echo
echo "Generated command(s):"

#if [ -z "$par02n" ]; then echo " ${RED}!!!Provide a value for 'IndexID'${RESTORE}"; else par02n=", $par02"; accept2=1; fi
if [ -z "$par01" ]; then echo " ${RED}!!!Provide a value for 'TableName'${RESTORE}";
    elif [ -z "$par02" ]; then echo " ${RED}!!!Provide a value for 'IndexID'${RESTORE}"; 
        elif [ ! -z "$par01" ] && [ ! -z "$par02" ]; then par02n=", $par02"; accept2=1;
         DB_LIST[$count]="${par00} ('${par01}'${par02n}${par04n}${par03n})"; accept=1; 
             echo " ${GREEN}$par20"
             echo " $par21"
             echo " $par23"            
             for string in "${DB_LIST[@]}"; do echo " $string"; done;
             echo "${RESTORE}"; fi 


echo "Standard keys (c - continue, n - add new table, d - delete the last command, r - reset, b - back)." 
read -p "Parameter (1..4): " choice 
case "$choice" in   b) set_page;;
                    c) go=1;;
                    n) count=$((count + 1)); unset par01 par02 par01n par02n accept;;
                    d) unset -v DB_LIST[$count]; DB_LIST=( "${DB_LIST[@]}" );;#unset 'DB_LIST[${#DB_LIST[@]}-1]';;
                    1) read -p "Enter only one table name: " par01;;
                    2) read -p "Enter Index ID: " par02;;
                    3) read -p "Enter ('FIX' or 'NOFIX'): " par03;;
                    4) read -p "Enter report type: " par04;; esac; done;

#if (( ${#source_files[@]} == 0 )); then exit 0; fi;

for string in "${DB_LIST[@]}"; do isql_request_nocolumns_bold "$par20" "$par21" "$par23" "$string"; done
pause; set_page
}



dbcc_textalloc(){
clear
echo "DBCC textalloc"
echo "The check ensures that:"
echo " - Text and image entries in the system tables are correct"
echo " - OAM page chain and allocation of OAM pages for text and image data are correct"
echo " - All text and image pages are correctly allocated"
echo " - No text page is allocated but not used"
echo " - No text page is used but not allocated"

CUR_SAP_SCHEMA="\"${SAP_SCHEMA}\""
par20="use ${SYBASE_SID}"
par21="setuser ${CUR_SAP_SCHEMA}"

while [ "$go" != 1 -o "$accept" != 1 -o "$accept2" != 1 ]; do echo

if [ -z "$par02" ]; then par02n=", OPTIMIZED"; par02="OPTIMIZED"; else par02n=", $par02"; fi
if [ -z "$par03" ] || [ "$par03" == "y" ]; then par03n=", FIX"; par03="FIX"; accept2=1; elif [ "$par03" == "n" ]; then par03n=", NOFIX"; par03="NOFIX"; accept2=1; fi


echo "${CYAN}1. Table name(s)*...............................................[$par01]${RESTORE}"
echo "2. Report type..................................................[$par02] (default: OPTIMIZED)"
echo "   OPTIMIZED: The allocation report generated by this mode, only reflects those allocation pages that were listed in the object's OAM pages."
echo "              Some 2540 errors may get missed by this report, if the information in the OAM pages is not accurate."
echo "    NOREPORT: Similar to FAST, but it does not correct 2521 errors." 
echo "              This mode does not deal with initializing the diagnostic bitmaps and expects a higher module to initialize all the bitmaps in all allocation pages."
echo "              Designed for a new version of checkalloc that uses concurrent textalloc to process the data."
echo "        FULL: This mode is a mini version of checkalloc. It reports all allocation errors that may exist in the table/index." 
echo "              It scans all allocation pages in the database to find extents allocated to the object requested."
echo "        FAST: This mode does not generate an allocation report, therefore it executes faster. The 2521 errors, if encountered in this report, may get corrected with the fix type of 'FIX'."
echo "              This is the fastest way of correcting 2521 in a table/index."
echo "3. Fix/Nofix inconsistencies....................................[$par03] (default: FIX)"
echo

echo "Generated command(s):"

if [[ -z "$par01" ]] || [[ "$accept2" = "0" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; 
else  
par01=$(echo $par01 | tr -d ' ')
delimiter=","
s=$par01$delimiter
arr_tables=(); arr_tables_isql=();
while [[ $s ]]; do arr_tables+=( "${s%%"$delimiter"*}" ); s=${s#*"$delimiter"}; done;
arr_tables_len="${#arr_tables[@]}"
for tbl in "${arr_tables[@]}"; do arr_tables_isql+=( " dbcc textalloc ('$tbl'$par02n$par03n) " ); done

echo "${GREEN}"
echo " $par20"
echo " $par21"
for string in "${arr_tables_isql[@]}"; do echo "$string"; done
echo "${RESTORE}"
accept=1; fi

echo 
echo "Standard keys (c - continue, r - reset, b - back)." 
read -p "Parameters (1..3): " choice 
case "$choice" in
                    b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars;;
                    1) read -p "Table name(s): " par01;;
                    2) read -p "Report type: " par02;;
                    3) read -p "Fix option (y/n): " par03;; esac; done;

for string in "${arr_tables_isql[@]}"; do isql_request_nocolumns_bold "$par20" "$par21" "$string"; done
pause; set_page
}


isql_show_big_tables(){
echo
read -p "How many the biggest tables should be displayed? (b - back): " par00
echo
case "$choice" in   b) set_page;;
                    1) read -p "Enter: " par00;; esac;

isql_session <<EOF
use ${SYBASE_SID}
go
SET ROWCOUNT ${par00}
go
select top ${par00} 
convert(varchar(30),o.name) AS table_name,
row_count(db_id(), o.id) AS row_count,
data_pages(db_id(), o.id, 0) AS pages,
data_pages(db_id(), o.id, 0) * (@@maxpagesize/1024) AS kbs
from sysobjects o where type = 'U' order by 4 desc
go
exit
EOF

#alternative query:
#
#select convert(varchar(30),o.name) AS table_name,
#row_count(db_id(), o.id) AS row_count,
#data_pages(db_id(), o.id, 0) AS pages,
#data_pages(db_id(), o.id, 0) * (@@maxpagesize/1024) AS kbs
#from sysobjects o where type = 'U' order by 4 desc
pause; set_page
}



bcp_table_export(){
clear
echo "Export tables with bcp"
while [ "$go" != 1 -o "$accept" != 1 -o "$accept2" != 1 ]; do echo;

if [[ ! -z "$par02" ]]; then 
    if [[ ! -d "$par02" ]]; then par02="!Directory does not exist!"; accept2=0; else
       if [[ ! -w "$par02" ]]; then par02="!Directory is not writable!"; accept2=0; else 
          if [ "$(ls -A $par02/)" ]; then par02="!Directory is not empty! Please clear it."; accept2=0; else accept2=1; fi; fi; fi; fi                              


echo "${CYAN}1. Table name(s)*..........................................[$par01]${RESTORE}"
echo "${CYAN}2. Output directory*.......................................[$par02]${RESTORE}"

echo
echo "Generated command(s):"
        
if [[ -z "$par01" ]] || [[ "$accept2" != "1" ]] || [[ -z "$par02" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; 
  else par01=$(echo $par01 | tr -d ' '); delimiter=","; s=$par01$delimiter; arr_tables=(); arr_tables_isql=();
while [[ $s ]]; do arr_tables+=( "${s%%"$delimiter"*}" ); s=${s#*"$delimiter"}; done;
arr_tables_len="${#arr_tables[@]}"
for tbl in "${arr_tables[@]}"; do FILENAME=$(echo ${tbl//[\/]/_})
                                  if [ -z "$STORE_KEY" ]; then arr_tables_isql_exp+=( " bcp ${SYBASE_SID}.${SAP_SCHEMA}.${tbl} out ${par02}/${FILENAME}.dat -S ${SYBASE_SID} -U sapsa -P ${SA_PASSWD} -c -e ${par02}/${FILENAME}.out.err -o $par02/${FILENAME}.out" );
                                                               arr_tables_isql_imp+=( " bcp ${SYBASE_SID}.${SAP_SCHEMA}.${tbl} in  ${par02}/${FILENAME}.dat -S ${SYBASE_SID} -U sapsa -P ${SA_PASSWD} -c -e ${par02}/${FILENAME}.in.err -o $par02/${FILENAME}.in " );          
                                                          else arr_tables_isql_exp+=( " bcp ${SYBASE_SID}.${SAP_SCHEMA}.${tbl} out ${par02}/${FILENAME}.dat -S ${SYBASE_SID} -k ${STORE_KEY} -c -e ${par02}/${FILENAME}.out.err -o ${par02}/${FILENAME}.out" ); 
                                                               arr_tables_isql_imp+=( " bcp ${SYBASE_SID}.${SAP_SCHEMA}.${tbl} in  ${par02}/${FILENAME}.dat -S ${SYBASE_SID} -k ${STORE_KEY} -c -e ${par02}/${FILENAME}.in.err -o ${par02}/${FILENAME}.in " ); fi; done                                                                                                                                                                        

for string in "${arr_tables_isql[@]}"; do echo "${GREEN} $string ${RESTORE}"; done
accept=1; fi
                                   
echo 
echo "Standard keys (c - continue, r - reset, b - back)." 
read -p "Parameters (1..2): " choice 
case "$choice" in
                    b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars;;
                    1) read -p "Enter table or tables (with delimiter ','): " par01;;
                    2) read -p "Enter output directory for dump files, out- and err-logs: " par02;; esac; done;

##bcp RFM.SAPSR3.BALDAT out /sybase/RFM/bcp/BALDAT.dat -S RFM -U SAPSR3 -P norinofu -c -e /sybase/RFM/bcp/BALDAT.err -o /sybase/RFM/bcp/BALDAT.out.log
bcp_imp_commands_file="$par02/_import_commands.txt"
touch ${bcp_imp_commands}
for string in "${arr_tables_isql_exp[@]}"; do echo ${string}; ${string}; done
for string in "${arr_tables_isql_imp[@]}"; do echo ${string} >> ${bcp_imp_commands_file}; done
#            if [ -z "$STORE_KEY" ];  then echo " bcp $SYBASE_SID.$SAP_SCHEMA.$tbl_name in $par02/$FILENAME -S $SYBASE_SID -U sapsa -P $SA_PASSWD -c -e $par02/$FILENAME.in.err -o $par02/$FILENAME.in " >> ${bcp_import_commands} 
#                                     else echo " bcp $SYBASE_SID.$SAP_SCHEMA.$tbl_name in $par02/$FILENAME -S $SYBASE_SID -k ${STORE_KEY} -c -e $par02/$FILENAME.in.err -o $par02/$FILENAME.in " >> ${bcp_import_commands}; fi 
#            done

#for tbl in "${arr_tables[@]}"; do FILENAME=$(echo ${tbl//[\/]/_})
#                                  if [ -z "$STORE_KEY" ]; then echo " bcp $SYBASE_SID.$SAP_SCHEMA.$tbl_name in $par02/$FILENAME -S $SYBASE_SID -U sapsa -P $SA_PASSWD -c -e $par02/$FILENAME.in.err -o $par02/$FILENAME.in " >> ${bcp_import_commands} 
#                                                          else echo " bcp $SYBASE_SID.$SAP_SCHEMA.$tbl_name in $par02/$FILENAME -S $SYBASE_SID -k ${STORE_KEY} -c -e $par02/$FILENAME.in.err -o $par02/$FILENAME.in " >> ${bcp_import_commands}; fi; done 



if [ "$(find $par02 -type f -name '*.err')" ]; then echo "WARN: ${RED}Please check *.in.err files in the directory $par02 ${RESTORE}"; else echo "INFO: ${GREEN}No ERR-files found. But anyway please check OUT-files!${RESTORE}"; fi
echo
echo "INFO: bcp import commands for the exported tables will be stored in ${bcp_import_commands}:"
cat ${bcp_imp_commands_file} 
pause; set_page
}


bcp_table_import(){
clear
echo "Import tables with bcp from dat-files"
echo 
#Turn on select into/bulkcopy (all versions)
par20="use master"
par21="sp_dboption $SYBASE_SID, \"select into/bulkcopy\", true"
par22="use $SYBASE_SID"
par23="checkpoint"

#Turn off select intobulkcopy
par24="sp_dboption $SYBASE_SID, \"select into/bulkcopy\", false"

while [ "$go" != 1 -o "$accept" != 1 -o "$accept2" != 1 ]; do echo
if [[ ! -z "$par01" ]]; then 
    if [[ ! -d "$par01" ]]; then par01="!Directory does not exist!"; accept=0; else
       if [[ ! -w "$par01" ]]; then par01="!Directory is not writable!"; accept=0; else
          if [ "${par01: -1}" != "/" ]; then par01="$par01"/; fi 
             dump_files=($(find $par01 -type f -name '*.dat' -print));
              if (( ${#dump_files[@]} == 0 )); then par01="!No dump files (.dat) found!"; accept=0; else accept=1; fi; fi; fi; fi;                              
                                                                                        

echo "${CYAN}1. Directory with dumps*...................................[$par01]${RESTORE}"
echo
echo "The next dat-file(s) have been found:"
for f in "${dump_files[@]}"; do echo "$f"; done; echo;

echo "Generated command(s):"
        
if [[ -z "$par01" ]] || [[ "$accept" != "1" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; 
  
elif [[ -z "$accept2" ]]; then for file in "${dump_files[@]}"; do                                   
  file_err=${file%????}; file_err="$file_err".in.err
  file_in=${file%????}; file_in="$file_in".in
  path_len=${#par01}
  tbl_name="${file:path_len}"; tbl_name=${tbl_name%????}
  bcp_import+=( " bcp $SYBASE_SID.$SAP_SCHEMA.$tbl_name in $par02$file -S $SYBASE_SID -U sapsa -P $SA_PASSWD -c -e $par02$file_err -o $par02$file_in " ); done
  
#Generated commands:
echo "${GREEN} $par20"
echo " $par21"
echo " $par22"
echo " $par23"
for command in "${bcp_import[@]}"; do echo "$command"; done
echo " $par20"
echo " $par24 ${RESTORE}"
accept2=1
else for command in "${bcp_import[@]}"; do echo "${GREEN}$command ${RESTORE}"; done; fi; 
echo                                   
echo "INFO: Don't forget to clean up the tables before import: TRUNCATE TABLE ${SYBASE_SID}.<TABLE_NAME>"
echo
echo "Standard keys (c - continue, r - reset, b - back)." 
read -p "Parameter (1): " choice 
case "$choice" in   b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars; unset bcp_import; unset dump_files;;
                    1) read -p "Enter directory with dump-files: " par01;; esac; done;
                    #2) read -p "Enter output directory for dump files, out- and err-logs: " par02;; 



#Execution:
isql_request_nocolumns_bold "$par20" "$par21" "$par22" "$par23"   
for string in "${bcp_import[@]}"; do echo "${string}"; 
${string}
echo; done
isql_request_nocolumns_bold "$par20" "$par24"

if [ "$(find $par01 -type f -name '*in.err')" ]; then echo "WARN: ${RED}Please check err-files in the directory $par01 ${RESTORE}"; else echo "INFO: ${GREEN}All commands have been executed successfully. Check in-files!${RESTORE}"; fi
pause; set_page
}



dump_db2file(){
clear
echo "Dump database(s) to a dump file"
echo
echo "Available databases of the instance $SYBASE_SID:"
isql_db_list; data_log_sizes_all_sql_sep

while [ "$go" != 1 -o "$accept" != 1 ]; do echo
if [[ ! -z "$par02" ]]; then 
    if [[ ! -d "$par02" ]]; then par02="!Directory does not exist!"; accept2=0; else
       if [[ ! -w "$par02" ]]; then par02="!Directory is not writable!"; accept2=0; else
          if [ "${par02: -1}" != "/" ]; then par02="$par02"/; accept2=1; fi; fi; fi; fi;  


echo "${CYAN}1. Database name(s)*.......................................[$par01]${RESTORE}"
echo "${CYAN}2. Output directory*.......................................[$par02]${RESTORE}"
echo "3. Compression.............................................[$par03] (default: n)"
echo "4. File distinguishing mark................................[$par04] (Use admissible symbols for UNIX-filenames)"
echo

if [ ! -z "$par02" ]; then par20=$(df -h "$par02" | egrep -v Filesystem | awk '{ print $4 }'); echo "${BOLD}Free space in this directory: $par20"${RESTORE}; fi

echo "Generated command(s):"
if [ "$par03" == "y" ]; then par03n="compression";fi
if [ ! -z "$par04" ]; then par04n=".$par04";fi

if [[ -z "$par01" ]] || [[ -z "$par02" ]] || [[ "$accept2" = "0" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; 
else  
par01=$(echo $par01 | tr -d ' ')
delimiter=","; s=$par01$delimiter; arr_tables=(); arr_tables_isql=();
while [[ $s ]]; do arr_tables+=( "${s%%"$delimiter"*}" ); s=${s#*"$delimiter"}; done;
arr_tables_len="${#arr_tables[@]}"
for db in "${arr_tables[@]}"; do arr_tables_isql+=( " dump database $db to \"$par02$db$par04n.dmp\" $par03n" ); done
for string in "${arr_tables_isql[@]}"; do echo "${GREEN} $string ${RESTORE}"; done; accept=1; fi
                                   
echo 
echo "Standard keys (c - continue, r - reset, b - back)." 
read -p "Parameters (1..4): " choice 
case "$choice" in
                    b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars;;
                    1) read -p "Enter database name(s) with delimiter ',': " par01;;
                    2) read -p "Enter a valid directory for dumps: " par02;;
                    3) read -p "Enter compression flag (y/n): " par03;;
                    4) read -p "Enter file distinguisching mark: " par04;; esac; done;

for string in "${arr_tables_isql[@]}"; do isql_request_nocolumns_bold "use master" "$string"; done

pause; set_page
}

dump_file2db(){
clear
echo "Dump-file to a database"
echo
while [ "$go" != 1 -o "$accept1" != 1 -o "$accept2" != 1 ]; do echo

if [[ ! -z "$par01" ]]; then 
    if [[ ! -d "$par01" ]]; then par01="!Directory does not exist!"; accept1=0; else
       if [[ ! -w "$par01" ]]; then par01="!Directory is not writable!"; accept1=0; else
          if [ "${par01: -1}" != "/" ]; then par01="$par01"/; fi 
             dump_files=($(find $par01 -maxdepth 1 -type f -name '*' -print));
              if (( ${#dump_files[@]} == 0 )); then par01="!No files found!"; accept1=0; else accept1=1; 
                #dump_dir_ls=$(ls "$par01");
                echo "In the directory are presented the next files:"
                counter=0
                for i in ${!dump_files[*]};
                  do printf "%4d "\-\>" %s\n" "$counter" "${dump_files[$i]}"
                  ((counter++)); done; fi; fi; fi; fi;                              

if [[ ! -z "$par02" ]] || [[ "$accept2" = "1" ]]; then par02n="${dump_files[$par02]}"; if  [[ -f "$par02n" ]]; then accept2=1; fi; else accept2=0; fi

if [[ ! -z "$par03" ]]; then accept3=1;fi
                                                                                      
echo
echo "${CYAN}1. Directory with dumps....................................[$par01]${RESTORE}"
if [ "$accept1" = "1" ]; then echo "${CYAN}2. Selected dump-file......................................[$par02n]${RESTORE}"; fi
if [ "$accept2" = "1" ]; then echo "${CYAN}3. Target database.........................................[$par03]${RESTORE}"; fi
echo
echo "Generated command(s):"
       
if [[ "$accept3" != "1" ]] ; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}";
      if [[ ! -z "$par02" ]]; then echo "Available databases of the instance $SYBASE_SID:"; isql_db_list; fi 
      else string1="load transaction $par03 from '$par02n' with headeronly";  
           string2="load database $par03 from '$par02n'";
           string3="online database $par03" 
           echo "${GREEN} $string1 ${RESTORE}:"; isql_request "use master" "$string1"; 
           echo "Generated command(s):"; echo "${GREEN} $string2 ${RESTORE}"; fi

echo 
echo "Standard keys (c - continue, r - reset, b - back)" 
read -p "Parameters: " choice 
case "$choice" in
                    b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars; unset bcp_import; unset dump_files;;
                    1) read -p "Enter directory with dump-files: " par01;; 
                    2) read -p "Enter the number of file: " par02;; 
                    3) read -p "Enter database for import: " par03;; esac; done;

isql_request "use master" "$string2"

echo 
read -p "Bring the database $par03 to ONLINE? (y/n): " answer
case "$answer" in
                    n) set_page;;
                    y) ;; esac;  

isql_request "use master" "$string3"
pause; set_page
}

dbcc_checkcatalog(){
clear
echo "Check the consistency of the system tables for a database"
echo "Dbcc checkcatalog validates:" 
echo 
echo "- Each entry in syscolumns must have an entry in sysobjects and systypes"
echo "- Each sysobjects row must have an entry in either syscolumns or sysprocedures based on the type of object"
echo "- Each sysprocedures row must have an entry in sysobjects"
echo "- Each sysindexes entry has data in sysobjects and syssegments"
echo "- The segmap values for each fragment in sysusages has a matching entry in syssegments"
echo "- The last checkpoint entry in syslogs is correct"
echo "- Checks that each compiled object has entries in syscomments"
echo "- Runs consistency checks for Sysindexes (12.5.2 and above, CR 334620)."
echo
isql_db_list 
while [ "$go" != 1 -o "$accept" != 1 ]; do 
echo "${CYAN}1. Database name(s)*.......................................[$par01]${RESTORE}"
echo "${CYAN}2. Option*.................................................[$par02]${RESTORE}"
echo "		fix - Fixes errors: 15049, 15050, 15051, 15052 and 15053. These errors can result from consistency checks for Sysindexes. System tables are not included."
echo "		all - Includes system tables in the new consistency checks (check consistency only, no fix)."
echo "		fixall - Includes the System tables in the fix command."
echo

par20="use ${SYBASE_SID}"

echo "Generated command(s):"
par00n="dbcc checkcatalog"
if [ ! -z "$par02" ]; then par02n=", $par02"; fi
if [[ -z "$par01" ]] || [[ -z "$par02" ]]; then echo " ${RED}!!!Provide all ${CYAN}cyan${RED} mandatory fields!!!${RESTORE}"; 
  else par01=$(echo $par01 | tr -d ' '); delimiter=","; s=$par01$delimiter; arr_tables=(); arr_tables_isql=();
while [[ $s ]]; do arr_tables+=( "${s%%"$delimiter"*}" ); s=${s#*"$delimiter"}; done;
arr_tables_len="${#arr_tables[@]}"
for tbl in "${arr_tables[@]}"; do arr_tables_isql+=( "$par00n ($tbl $par02n)" ); done
for string in "${arr_tables_isql[@]}"; do echo "${GREEN} $string ${RESTORE}"; done
accept=1; fi
                                   
echo 
echo "Standard keys (c - continue, r - reset, b - back)." 
read -p "Parameters (1..2): " choice 
case "$choice" in
                    b) set_page;;
                    c) go=1;;
                    r) unset_temp_vars;;
                    1) read -p "Enter database name: " par01;;
                    2) read -p "Enter option: " par02;; esac; done;

for string in "${arr_tables_isql[@]}"; do isql_request_nocolumns_bold "$par20" "$string"; done
pause; set_page
}


syscopy_adapt_logthresholds_sid(){
# Umsetzung der log thresholds bei Systemkopie auf neue SID: \\itoswd\itoshare\appl\sap\05_DB\SAPASE\ASESkripts\syscopy_adapt_logthresholds_sid.sql
isql_session <<EOF
use @@servername
go

exec sp_helpthreshold
go

declare THRESH_CURSOR cursor FOR select free_space from systhresholds
go
declare @FREESPACE integer
declare @ADDTHRESH varchar(100)
set @ADDTHRESH = @@servername+'..sp_thresholdaction_lgdump'
open THRESH_CURSOR
fetch THRESH_CURSOR into @FREESPACE
while @@sqlstatus = 0
begin
  exec sp_dropthreshold @@servername, logsegment, @FREESPACE
  exec sp_addthreshold @@servername, logsegment, @FREESPACE, @ADDTHRESH
  fetch THRESH_CURSOR into @FREESPACE
end
close THRESH_CURSOR
deallocate THRESH_CURSOR
go

exec sp_helpthreshold
go
exit
EOF
pause; set_page
}

unlock_abap_user(){
clear
read -p "Enter ABAP-user name for unlocking: " par00
read -p "Enter his ABAP client number [e.g. 001]: " par01

par10="update "$SAP_SCHEMA".USR02 set UFLAG=0 where BNAME='$par00' and MANDT='$par01'"
par11="select BNAME, MANDT, UFLAG from "$SAP_SCHEMA".USR02 where BNAME ='$par00' and MANDT='$par01'"
par20="use $SYBASE_SID"

echo " $par20"
echo " $par10"
echo " $par11"

ask_proceed_yn
#while [ "$yn" != 1 ]; do echo
#        echo "The next command will be executed:"
#        echo "${GREEN} ${par10} ${RESTORE}"
#        read -p "Proceed? [y - yes, e - edit, b - back]: " yn
#        case "$yn" in
#                    y) yn=1; break;;
#                    e) yn=0; read -p "$par10 -> " par10;;
#                    b) unset_temp_vars; set_page;; esac; done;


isql_request_columns_nobold "$par20" "$par10" "$par11"

#isql_session_e <<EOF
#use ${SYBASE_SID}
#go
#${par10}
#go
#${par11}
#go
#exit
#EOF
pause; set_page
}


isql_active_sessions(){
bold_text
isql_session <<EOF
SET NOCOUNT ON
SET PROC_RETURN_STATUS OFF
select spid, cmd, status, hostname, clientname, clientapplname, priority from master..sysprocesses where clientname '%SAPSYS%'
go
exit
EOF
set_page
}

isql_sap_sessions(){
bold_text
isql_session <<EOF
SET NOCOUNT ON
SET PROC_RETURN_STATUS OFF
select spid, cmd, status, hostname, clientname, clientapplname, priority from master..sysprocesses where status ='running'
go
exit
EOF
set_page
}

isql_all_sessions(){
bold_text
isql_session <<EOF
SET NOCOUNT ON
SET PROC_RETURN_STATUS OFF
select spid, cmd, status, hostname, clientname, clientapplname, priority from master..sysprocesses
go
exit
EOF
set_page
}


isql_mon_wait_event_info(){
#SET NOCOUNT ON
#SET PROC_RETURN_STATUS OFF
isql_session <<EOF
select convert(varchar(20),w.Waits) as "Waits", convert(varchar(15),w.WaitTime) as "Wait Time", convert(varchar(4),w.WaitEventID) as "EventID", convert(varchar(100),i.Description) as "Wait Event ID Description" from master..monSysWaits w, master..monWaitEventInfo i where w.WaitEventID = i.WaitEventID order by w.WaitTime desc
go
exit
EOF
echo "INFO: Find more information: ${CYAN}https://wiki.scn.sap.com/wiki/display/SYBASE/ASE+Wait+Events${RESTORE}"
pause; set_page
}


isql_mon_memory_usage(){
isql_session <<EOF
use master
go
select TotalSize as "TotalSize, Bytes",  
  case 
  WHEN TotalSize != 0 or UsedSize !=0 THEN convert(varchar(6),(UsedSize* 100 / TotalSize)) 
  end as "% Used", convert(varchar(8),PoolType) as "PoolType", PoolOwnerKPID, MemoryPoolName
from monMemoryUsage where TotalSize != 0 or UsedSize !=0 or FreeSize != 0 order by 2 desc
go
exit
EOF
pause; set_page
}


isql_sysprocesses(){
clear
isql_session <<EOF
use master
go
select             
 convert(varchar(6),hostprocess) as "Proc",
 status,                              
 convert(varchar(10),case WHEN hostname = NULL THEN '-' else hostname end) as "Hostname",  
 convert(varchar(18),cmd) as "Command",                             
 convert(varchar(4),cpu) as "CPU",
 convert(varchar(10),physical_io) as "Physical IO",                              
 convert(varchar(8),memusage) as "Memory",                              
 blocked,                              
 dbid,                              
 id,                              
 convert(varchar(20),clientname) as ClientName,                              
 convert(varchar(10),clienthostname) as Clienthostname,
 convert(varchar(10),clientapplname) as Clientapplname,
 convert(varchar(20),loggedindatetime) as Loggedindatetime,                              
 convert(varchar(16),ipaddr) as "IP-addr",                              
 convert(varchar(10),case WHEN execution_time = NULL THEN '-' else execution_time end) as "Exec.time" 
 from sysprocesses order by 2 desc, 5 desc
go
exit
EOF
pause; set_page
}                                                                                                                                                                                      


isql_show_db_users(){
clear
par20=$(isql_request "use master" "select name from sysdatabases")
SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"

isql_request "use master" "select name as DatabaseName from sysdatabases"
echo
while true; do read -p "Enter the ${BOLD}database name${RESTORE}: " par21
if [[ " ${par20[@]} " =~ " ${par21} " ]]; then :; break; else echo "${RED}WARN: Enter a valid database name!${RESTORE}"; fi; done

par21="use $par21" 
#isql_request_02 "$par21" "select name as DatabaseOwner from sysusers"
isql_request_columns_nobold "$par21" "select name as DatabaseOwner from sysusers" 
pause; set_page
}


isql_move_data_file(){
clear
echo "Move files from one location to another one."

echo " ${GREEN}sp_configure 'disable disk mirroring',0${RESTORE}"
isql_request_columns_bold "use master" "sp_configure 'disable disk mirroring',0"; nobold_text

echo "${RED}INFO: '${RESTORE}${BOLD}Run Value${RESTORE}${RED}' of the parameter should be 0. If so, you may proceed.${RESTORE}"
 
ask_proceed_yn

echo "The instance has the next devices and it's locations:"
isql_request_columns_nobold "use master" "select name as DeviceName, phyname as PhysicalLocation from sysdevices order by 1"

par00=$(isql_request "use master" "select name from sysdevices")
SAVEIFS="$IFS"; IFS=$'\n'; par00=($par00); IFS="$SAVEIFS"

while true; do read -p "Enter the ${BOLD}device name${RESTORE} that must be moved: " par01
if [[ " ${par00[@]} " =~ " ${par01} " ]]; then :; break; else echo "${RED}WARN: Enter a valid device name!${RESTORE}"; fi; done

par02="select phyname from sysdevices where name = '$par01'"
par03=$(isql_request "use master" "$par02"); par03=$(echo $par03)
echo "INFO: Source datafile location: $par03"
par05=$(du -m $par03 | awk '{ print $1 }' )

while true; do read -p "Enter the ${BOLD}destination file location${RESTORE}: " par04

if [ ! -e $par04 ]; then if touch "$par04"; then par07=$(df -m $par04 | egrep -v Filesystem | awk '{ print $4 }'); rm "$par04";
                         if (( "$par07" > "$par05" )); then break; 
                         else echo "${RED}ERROR: Filesystem is too small for the data-file${RESTORE}"; continue; fi;
      else echo "${RED}ERROR: No permissions to create the file${RESTORE}"; continue; fi 
else echo "ERROR: File already exists"; continue; fi; done  

par01="$par01"
par04="$par04"
par08="disk mirror name=\"${par01}\", mirror=\"${par04}\""
par09="disk unmirror name=\"$par01\", side=\"primary\", mode=\"remove\""

while [ "$run" != 1 ]; do echo                              
        echo "The next command will be executed:"
        echo " ${GREEN}${par08}"
        echo " ${par09}${RESTORE}"
        read -p "Proceed? [y - yes, e1 - edit 1st. command, e2 - edit 2nd. command, b - back]: " answer
        case "$answer" in
                    y) run=1; break;;
                    e1) run=0; read -p "$par08 -> " par08;;
                    e2) run=0; read -p "$par09 -> " par09;;
                    b) set_page;; esac; done;

isql_request_columns_nobold "use master" "$par08"
isql_request_columns_nobold "use master" "$par09"

echo "INFO: Check the results:"
par10="sp_helpdevice $par01" 
isql_request_columns_nobold "use master" "$par10"

par30="$(du -h $par03 | awk '{ print $1 }')"; par30=${par30%?}
par31="$(du -h $par04 | awk '{ print $1 }')"; par31=${par31%?}
echo "INFO: Size of source-file: ${par30}MB"
echo "INFO: Size of destination-file: ${par31}MB"
#if [ "$par30" -eq "$par31" ]; then echo "INFO: The sizes ${GREEN}identic${RESTORE}"; 
#                              else echo "${YELLOW}WARNING: The sizes of source and destination files not identic${RESTORE}"; fi

if [ -e "$par04" ]; then read -p "${BOLD}Delete SOURCE-file${RESTORE} $par03? (y/n): " yn
                         case "$yn" in y) rm -v "$par03";;
                                       n) set_page;; esac;
                    else echo "${RED}ERROR: The file cannot be removed. Check the logs above.${RESTORE}"; fi
set_page
}


isql_drop_device(){
clear
echo "Drop data- or log-device"
echo
echo "Available databases:"
isql_db_list
echo
par20=$(isql_request "use master" "select name from sysdatabases"); SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"

while [ -z "$par21" ]; do read -p "Enter database name (or 'b' to return back): " par21
                          case "$par21" in b) set_page;;
                                           *) if [[ ! " ${par20[@]} " =~ " ${par21} " ]]; then echo "${RED}WARN: Enter a valid database name!${RESTORE}"; unset par21; continue; 
                                                                                          else break; fi; esac; done; 
                                                                                          
echo "The instance has the next devices and it's locations:"
isql_request_nocolumns_nobold "use master" "select name as DeviceName, phyname as PhysicalLocation from sysdevices where name like \"%$par21%\" order by 1"

par00=$(isql_request "use master" "select name from sysdevices"); SAVEIFS="$IFS"; IFS=$'\n'; par00=($par00); IFS="$SAVEIFS"
while true; do read -p "Enter the ${BOLD}device name${RESTORE} that must be dropped: " par01
if [[ " ${par00[@]} " =~ " ${par01} " ]]; then :; break; else echo "${RED}WARN: Enter a valid device name!${RESTORE}"; fi; done


array00=(); if [[ "$par01" == *"log"* ]]; then array00+=( "use master" );
                                               array00+=( "ALTER DATABASE ${par21} LOG OFF ${par01}" );
                                               array00+=( "sp_dropdevice ${par01}" ); 
    elif [[ "$par01" == *"data"* ]]; then array00+=( "use master" )
                                          array00+=( "sp_dropdevice ${par01}" );
    else echo "ERROR: The device type (device or log) cannot be determinated. You want to delete not usual data/log-device. Please contact the developer to add this feature."; fi

                            
par03=$(isql_request_nocolumns_nobold "use master" "select phyname from sysdevices where name like \"%$par01%\""); par03=($par03)

echo "Generated command(s):"
for i in "${array00[@]}"; do echo " ${GREEN}${i}${RESTORE}"; done
ask_proceed_yn

isql_request_nocolumns_bold "${array00[@]}"


#isql_request_nocolumns_nobold_verbose "use master"
#arr_traceflags_commands=("${arrayClone[@]}")

tail_rows "4"

par00=$(isql_request "use master" "select name from sysdevices"); SAVEIFS="$IFS"; IFS=$'\n'; par00=($par00); IFS="$SAVEIFS"
if [[ ! " ${par00[@]} " =~ " ${par01} " ]]; then echo "${GREEN}INFO: Device has been deleted from ASE $par21 successfully${RESTORE}"; else echo "${RED}ERROR: Device has not be deleted from ASE!${RESTORE}"; set_page; fi

echo

if [[ ! " ${par00[@]} " =~ " ${par01} " ]]; then read -p "${RED}Delete device file${RESTORE} $par03? (yes/no): " yn
                                               case "$yn" in yes) rm -v $par03;;
                                                             no) set_page;; esac; fi 
                                          #else echo "ERR: The file cannot be deleted."; fi

pause; set_page
}


isql_schrink_logdev(){
clear
echo "Schrink transaction log device"

par10=$(isql_request "use master" "select name from sysdevices")
SAVEIFS="$IFS"; IFS=$'\n'; par10=($par10); IFS="$SAVEIFS"

par20=$(isql_request "use master" "select name from sysdatabases")
SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"

isql_request_columns_nobold "use master" "sp_helpdevice"

while true; do read -p "Enter the ${BOLD}database name${RESTORE} that must be resized: " par21
if [[ " ${par20[@]} " =~ " ${par21} " ]]; then :; break; else echo "${RED}WARN: Enter a valid database name!${RESTORE}"; fi; done

while true; do read -p "Enter the ${BOLD}log-device_name${RESTORE} that must be resized: " data_dev
if [[ " ${par10[@]} " =~ " ${data_dev} " ]]; then :; break; else echo "${RED}WARN: Enter a valid device_name!${RESTORE}"; fi; done

par10="select phyname from sysdevices where name = '$data_dev'"
data_dev_file=$(isql_request "use master" "$par10"); data_dev_file=$(echo $data_dev_file)

db_dev_file_size=$(du -m $data_dev_file | awk '{ print $1 }' )

echo "INFO: Current size of log_dev: ${db_dev_file_size} MB"

while true; do read -p "Enter ${BOLD}size (in MB)${RESTORE} that must be schrunk from $data_dev: " par12
if (( "$db_dev_file_size" > "$par12" )); then :; break; else echo "${RED}ERROR: Schrink-size must be smaller than the log-device size!${RESTORE}"; fi; done

par13="dump tran ${par21} with truncate_only"
par14="alter database ${par21} log off ${data_dev} = $par12"
par15="sp_helpdevice ${data_dev}"; #isql_request_columns_bold "use master" "$par11"

while true; do echo
        echo "The next command will be executed:"
        echo " ${GREEN}${par13}"                                                                     
        echo " ${par14}${RESTORE}"
        read -p "Proceed? [y - yes, b - back]: " yn
        case "$yn" in
                    y) break;;
                    b) set_page;; esac; done;

isql_request_columns_bold "use master" "$par13" "$par14"; nobold_text

echo "Check the results:"
isql_request_columns_nobold "use master" "$par15"
pause; set_page
}

archive_mode(){
echo
echo "No- or Archive mode activation:" 
echo
echo "0 - Noarchive Mode"
echo "1 - Archive Mode"
echo "b - back"
while true; do read -p "Which mode should be activated: " par01
  case "$par01" in
                    0) break;;
                    1) break;;
                    b) set_page;; esac; done;
if [ "$par01" = "0" ]; then par02="sp_dboption ${SYBASE_SID}, 'trunc log on chkpt',true"; else par02="sp_dboption ${SYBASE_SID}, 'trunc log on chkpt',false"; fi
echo "Generated command:" 
echo "${GREEN} use master"
echo " $par02 ${RESTORE}"
ask_proceed_yn
isql_request_columns_bold "use master" "$par02"
pause; set_page
}

dbcc_gam(){
clear
echo
echo "DBCC GAM:"
echo "Detect and correct invalid bit settings in SYSGAMS within a database." 
echo "SYSGAMS is a disk-based data structure that contains one bit for each allocation unit in the database. If all 32 extents on the allocation unit are allocated, the bit is set on."
echo "The general extent allocation algorithm checks sysgams to avoid searching for free extents on fully-allocated allocation units. Premature 1105 errors may be raised if some sysgam bits are incorrectly set on for allocation units that have free extents."


isql_db_list
par20=$(isql_request "use master" "select name from sysdatabases")
SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"

while true; do echo; read -p "Enter the ${BOLD}database name${RESTORE} that must be put in single-user mode: " par21
if [[ " ${par20[@]} " =~ " ${par21} " ]]; then :; break; else echo "${RED}WARN: Enter a valid database name!${RESTORE}"; fi; done

echo "Generated command(s):"
par00="use master"
par01="dbcc gam (${par21})"

echo "${GREEN} ${par00}"
echo " ${par01}"
echo "${RESTORE}"

ask_proceed_yn
isql_request_columns_bold "$par00" "$par01"
pause; set_page
}

sql_syslocks(){
par00="select * from syslocks"
echo "${GREEN}${par00}${RESTORE}"
isql_request_columns_bold "use master" "$par00"
set_page
}


dbcc_tablealloc(){
echo 
echo "Validate and/or fix the integrity of a table's allocation."
echo "Tablealloc provides basically the same functionality as checkalloc except on a per object basis."
echo

isql_db_list
par20=$(isql_request "use master" "select name from sysdatabases")
SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"
while true; do echo; read -p "Enter the ${BOLD}database name${RESTORE}: " par00
if [[ " ${par20[@]} " =~ " ${par00} " ]]; then :; break; else echo "${RED}WARN: Enter a valid database name!${RESTORE}"; fi; done

#default values:
par22="DBCC TABLEALLOC" 
par02="NOFIX"
par03="OPTIMIZED"
#CUR_SAP_SCHEMA="\"${SAP_SCHEMA}\""
CUR_SAP_SCHEMA="${SAP_SCHEMA}"
par23="set quoted_identifier on"            
par20="use ${par00}"
par21="setuser \"${CUR_SAP_SCHEMA}\""
count=0
#while [ "$go" != 1 -o "$accept" != 1 -o "$accept2" != 1 ]; do echo 
while [ "$go" != 1 -o "$accept" != 1 ]; do echo
if [ "$par02" = "FIX" ]; then par02n=", FIX"; 
    elif [ "$par02" = "NOFIX" ]; then par02n=", NOFIX"; 
    else par02="${RED}!!!Please select: FIX or NOFIX!!!${RESTORE}"; fi

if [ "$par03" = "OPTIMIZED" ]; then par03n=", $par03";
     elif [ "$par03" = "FULL" ] || [ "$par03" = "FAST" ] || [ "$par03" = "NULL" ]; then par03n=", $par03"
     else par03="${RED}!!!Please select a valid report type!!!${RESTORE}"; fi
echo
echo "1. Database name............................................[$par00]"
echo "${CYAN}2. Table(s) name*...........................................[$par01]${RESTORE}"
echo "3. Fix option...............................................[$par02] (Default: 'NOFIX'; 'FIX': correct any allocation errors encountered)"
echo "4. Report type..............................................[$par03] (Default: OPTIMIZED)"
echo "	- OPTIMIZED (Reflects those allocation pages that were listed in the object's OAM pages. Some 2540 errors may get missed by this report, if the information in the OAM pages is not accurate)"
echo "	- FULL (It reports all allocation errors that may exist in the table/index. It scans all allocation pages in the database to find extents allocated to the object requested)"
echo "	- FAST (This mode does not generate an allocation report, therefore it executes faster. The 2521 errors, if encountered in this report, may get corrected with the fix type of 'FIX')"
echo "                   This is the fastest way of correcting 2521)"
echo "	- NULL (Similar to FAST, but it does not correct 2521 errors." 
echo "                   This mode does not deal with initializing the diagnostic bitmaps and expects a higher module to initialize all the bitmaps in all allocation pages)"

#echo "count= $count"
echo

if [ -z "$par01" ]; then echo " ${RED}!!!Provide a value for 'TableName'${RESTORE}"; echo; else
par01=$(echo $par01 | tr -d ' ')
delimiter=","
s="$par01$delimiter"
arr_tables=(); arr_tables_isql=();
while [[ "$s" ]]; do arr_tables+=( "${s%%"$delimiter"*}" ); s=${s#*"$delimiter"}; done;
arr_tables_len="${#arr_tables[@]}"
for string in "${arr_tables[@]}"; do arr_tables_isql+=( "$par22 (\"$string\"$par03n$par02n) " ); done
echo "Generated commands:"
echo "${GREEN} $par23"
echo " $par20"
echo " $par21"
for string in "${arr_tables_isql[@]}"; do echo " $string"; done
echo "${RESTORE}"
accept=1; fi

#if [ -z "$par01" ]; then echo " ${RED}!!!Provide a value for 'TableName'${RESTORE}";
#    elif [ -z "$par02" ]; then echo " ${RED}!!!Provide a value for 'IndexID'${RESTORE}"; 
#        elif [ ! -z "$par01" ] && [ ! -z "$par02" ]; then par02n=", $par02"; accept2=1;
#             DB_LIST[$count]="${par00} ('${par01}'${par02n}${par04n}${par03n})"; accept=1; 
#             echo " ${GREEN}$par20"
#             echo " $par21"
#             echo " $par23"            
#             for string in "${DB_LIST[@]}"; do echo " $string"; done;
#             echo "${RESTORE}"; fi 


echo "Standard keys (c - continue, r - reset, b - back)." 
read -p "Parameter (2..4): " choice 
case "$choice" in   b) set_page;;
                    r) unset_temp_vars;;
                    c) go=1;;
                    2) read -p "Enter tables name (delemiter ','): " par01;;
                    3) read -p "Enter ('FIX' or 'NOFIX'): " par02;;
                    4) read -p "Enter report type: " par03;; esac; done;

#if (( ${#source_files[@]} == 0 )); then exit 0; fi;

for string in "${arr_tables_isql[@]}"; do echo "$string"; isql_request_nocolumns_bold "$par20" "$par21" "$par23" "$string"; done
pause; set_page
# dbcc tablealloc (BALDAT, full, fix)
}


dbcc_dbrepair(){
clear
echo "Update or repair various information for a database DBCC-REPAIR"
echo
 
isql_db_list
par20=$(isql_request "use master" "select name from sysdatabases")
SAVEIFS="$IFS"; IFS=$'\n'; par20=($par20); IFS="$SAVEIFS"
while true; do echo; read -p "Enter the ${BOLD}database name${RESTORE}: " par00
if [[ " ${par20[@]} " =~ " ${par00} " ]]; then :; break; else echo "${RED}WARN: Enter a valid database name!${RESTORE}"; fi; done

###arrayClone=("${arr_traceflags_commands[@]}"); #unset arr_traceflags_commands; 
###arr_traceflags_commands=() 
array00=()

while [ "$go" != 1 -o "$accept" != 1 ]; do echo
echo "1. Database name............................................[$par00]"
echo "${CYAN}2. Action/Option for dbrepair...............................[$par11]${RESTORE}"
echo "---------------------------------------"
echo "|#  |Needs Single-Mode|Action/Option  |  -> Please read before usage: ${MAGENDA}https://wiki.scn.sap.com/wiki/display/SYBASE/DBCC+dbrepair${RESTORE}"
echo "---------------------------------------"
echo "|1  |NO               |dropdb         |"
echo "|2  |YES              |findstranded   |"
echo "|3  |NO               |flushthreshold |"
echo "|4  |NO               |ltmignore      |"
echo "|5  |NO               |newthreshold   |"
echo "|6  |NO               |remap          |"
echo "|7  |NO               |repairindex    |"
echo "|8  |NO               |updowner       |"
echo "|9  |NO               |readpage       |"
echo "|10 |NO               |writepage      |"
echo "|11 |NO               |flushthreshold |"                                                  
echo "|12 |NO               |dropproxydb    |"
echo "|13 |YES              |fixlogfreespace|"
echo "|14 |NO               |upd_usg        |"
echo "---------------------------------------"
echo
echo "Generated commands:"

if [ -z "$par01" ]; then accept=0;
                    else if [ ${#array00[@]} -eq 0 ]; then par11="$par01"; array00+=( "use master" );
                      
                      if [ "$par01" = 1 ]; then array00+=( "update master..sysdatabases set status=320 where name='$par00'" ) 
                                                array00+=( "dbcc dbrepair ($par00, dropdb)" ); 
                      elif [ "$par01" = 2 ]; then echo "${YELLOW}!INFO: SAP application must be stopped before you start the commands!${RESTORE}";
                                                  array00+=( "sp_dboption ${par00}, \"single\", true" ); 
                                                  array00+=( "dbcc dbrepair (${par00}, findstranded)" );
                                                  array00+=( "sp_dboption ${par00}, \"single\", false");
                      elif [ "$par01" = 3 ]; then echo "ERROR: UNDER CONSTRUCTION"; set_page;
                      elif [ "$par01" = 4 ]; then echo "ERROR: UNDER CONSTRUCTION"; set_page;
                      elif [ "$par01" = 5 ]; then array00+=( "dbcc dbrepair (${par00}, newthreshold)" );
                      elif [ "$par01" = 6 ]; then array00+=( "dbcc dbrepair (${par00}, remap)" );
                      elif [ "$par01" = 7 ]; then array00+=( "use $par00" )
                                                  read -p "Enter the table name (The O_RAMBOIX bit will be activated): " par12
                                                  array00+=( "update sysobjects set sysstat= sysstat|4096 where name='$par12' ");
                                                  array00+=( "checkpoint" )
                                                  array00+=( "dbcc dbrepair(x,repairindex, $par12,1)" )
                                                  array00+=( "update sysobjects set sysstat = sysstat & ~4096 where name='$par12'" )
                                                  array00+=( "checkpoint" )
                      elif [ "$par01" = 8 ]; then echo "ERROR: UNDER CONSTRUCTION"; set_page;
                      elif [ "$par01" = 9 ]; then echo "ERROR: UNDER CONSTRUCTION"; set_page;
                      elif [ "$par01" = 10 ]; then echo "ERROR: UNDER CONSTRUCTION"; set_page;
                      elif [ "$par01" = 11 ]; then echo "ERROR: UNDER CONSTRUCTION"; set_page;
                      elif [ "$par01" = 12 ]; then echo "ERROR: UNDER CONSTRUCTION"; set_page;
                      elif [ "$par01" = 13 ]; then echo "${YELLOW}!INFO: SAP application must be stopped before you start the commands!${RESTORE}";
                                                   array00+=( "sp_dboption ${par00}, \"single\", true" );
                                                   array00+=( "dbcc dbrepair (${par00}, fixlogfreespace)" ); 
                                                   array00+=( "sp_dboption ${par00}, \"single\", false"); 
                      elif [ "$par01" = 14 ]; then echo "ERROR: UNDER CONSTRUCTION"; set_page; fi; fi; fi


#for e in "${array00[@]}"; do echo " ${GREEN}$e${RESTORE}"; done;

if [ -z "$par01" ]; then accept=0; echo "${RED}!!!Provide a valid value for 'Action'!!!${RESTORE}"; 
                    else accept=1; for e in "${array00[@]}"; do echo " ${GREEN}$e${RESTORE}"; done; fi

echo
echo "Standard keys (c - continue; r - reset; b - back)." 
read -p "Enter action [1-14]: " choice 
case "$choice" in b) set_page;; ###arr_traceflags_commands=(); arr_traceflags_commands=("${arrayClone[@]}"); set_page;;
                  [1-9]|[1][0-4]) par01="$choice"; accept=1;;
                  c) go=1; echo "The generated command(s) will be executed now."; ask_proceed_yn;;
                  r) unset array00 choice par01 par11;; 
                  *) unset choice; continue; esac; done;
 
#isql_request_nocolumns_bold "use master"
#arr_traceflags_commands

###arr_traceflags_commands=("${arrayClone[@]}")

#echo "DEBUG:"
#for e in "${arr_traceflags_commands[@]}"; do echo " ${GREEN}$e${RESTORE}"; done  

arr_traceflags_commands=("${array_clone00[@]}")
arr_traceflags_commands=("${array00[@]}")
isql_request_nocolumns_nobold "go" 
arr_traceflags_commands=("${array_clone00[@]}")

pause; set_page
}


print_dbcc_traceflags(){
isql_request_nocolumns_bold "use master" "dbcc traceflags"
}


zip_log_files(){
zip_file="_ASETOOLS_${SYBASE_SID}_${DT}.ZIP"
echo
echo "All script log files (instance $SYBASE_SID) will be packed to: ${zip_file}"
zip_log_command=" zip -m _ASETOOLS_${SYBASE_SID}_${DT}.ZIP _ASETOOLS_$(hostname)_${SYBASE_SID}_*.LOG"
echo "${GREEN} ${zip_log_command}${RESTORE}"
ask_proceed_yn
cp ${LOG_FILE} ${LOG_FILE}.bkp 
zip -m _ASETOOLS_${SYBASE_SID}_${DT}.ZIP _ASETOOLS_$(hostname)_${SYBASE_SID}_*.LOG
cp ${LOG_FILE}.bkp ${LOG_FILE}
pause; set_page
}


check_exitcode(){
if [ $? -eq 0 ]; then EXIT_CODE="${GREEN}SUCCESS${RESTORE}"; else EXIT_CODE="${RED}(${$?})${RESTORE}"; fi
echo ${EXIT_CODE}
}

print_array00(){
for e in "${array00[@]}"; do echo "$e"; done
echo
}


ase_update(){
clear
# 1. General envinroment parameters:
CTIME=$(date "+%Y.%m.%d-%H.%M.%S")
START=$(date +%s)

# 2. Company-specific parameters:
SHARE_MOUNT_POINT="/mnt/itoshare"
SAPCAR="$SHARE_MOUNT_POINT/SAP_KERNEL/SAPCAR"
PATCH_DIR="$SHARE_MOUNT_POINT/05_DB/SAPASE/Update/LINUX"
DB_PATCH="PATCH.SAR"
DB_CLIENT_PATCH="DBCLIENT.SAR"
PATCH_DIR_UNPACK="/tmp/ASEPATCH_$CTIME"
ASEUP_PATH="/sybase"
ASEUP_FILE="ASEup.sh"
SYB_UPDATE_DB_FILE="syb_update_db.TXT"
NFS_SHARE_01_ADDR="itoswd-nek.int.tds.rz"
NFS_SHARE_02_ADDR="itoswd"
NFS_SHARE_01_PATH="//itoswd-nek.int.tds.rz/itoshare/appl/sap"
NFS_SHARE_02_PATH="//itoswd/itoshare/appl/sap"
SHARE_USER_NAME="ito"
NFS_SHARE_PWD="jpdVfPHZmB7hXxR15p3W"
HOST_AGENT_PATH="$SHARE_MOUNT_POINT/SAP_KERNEL/hostagent/linuxx86_64"
OJDBC_DIR="/sapmnt/$SYBASE_SID/global/syb/"
OJDBC_DIR_BKP="/sapmnt/$SYBASE_SID/global/syb_BKP_$CTIME_$tdsuser"

# 3. Status array fillung
array00+=( " ${BOLD}PRE-DOWNTIME:${RESTORE}" )
array00+=( "[       ] mount itoshare" ) 
array00+=( "[       ] SAP Hostagent update" ) 
array00+=( "[       ] Save ASE parameters in log" ) 
array00+=( "[       ] Patch selection" ) 
array00+=( "[       ] Software & Prereqs. checks" ) 
array00+=( " ${BOLD}DOWNTIME:${RESTORE}" ) 
array00+=( "[       ] Stop patrol agent" ) 
array00+=( "[       ] Stop SAP & ASE" ) 
array00+=( "[       ] Save current /sybase to backup server" ) 
array00+=( "[       ] Start server again" ) 
array00+=( "[       ] Backup the latest database logs (recall script or via DasiWeb)" ) 
array00+=( "[       ] Check prerequisites 2" ) 
array00+=( "[       ] Update ASE Software" ) 
array00+=( "[       ] Update the ODBC and JDBC drivers" )   

echo "Installing Service Packs for SAP ASE"
echo
print_array00
ask_proceed_yn
# Check X-env.
#echo "Please ${YELLOW}start Xming${RESTORE} on your PC"; pause
#if [ ! -z "$DISPLAY" ]; then echo "INFO: Testing X-envonroment from user root: DISPLAY=$DISPLAY ${GREEN}- OK${RESTORE}"; else echo "ERROR: No \$DISPLAY environment set for user root. Trying default (localhost:0.0)"; DISPLAY=localhost:10.0; fi
#if xclock; then echo "INFO: X-envinronment tested: ${GREEN}OK${RESTORE}"; else echo "ERROR: xclock not available or X apps cannot be started. Please check your X-envinroment."; set_page; fi
#echo
#if command -v xclock &>/dev/null; then echo "INFO: xclock is available on the server"; else echo "ERROR: xclock not available. Please check your X-envinroment."; set_page; fi
#echo
#par55=$(xauth list $DISPLAY)
#par56="$DISPLAY"
#echo "INFO: Testing of X-envonroment of user $sybase_user:"
#su "$sybase_user" -c "xauth add $par55 && setenv DISPLAY $par56 && xclock"
#echo
#echo "Have you seen the xclock 2 times and close it?"
#ask_proceed_yn 


# Mount itoshare [1]
TASK_NUMBER=1
clear
if [ ! -d "$SHARE_MOUNT_POINT" ]; then mkdir -p "$SHARE_MOUNT_POINT" > /dev/null; fi
if [ -d "$PATCH_DIR" ]; then echo "INFO: The directory $PATCH_DIR is available"; check_exitcode; array00[$TASK_NUMBER]="[$EXIT_CODE] mount itoshare" 
                        else echo "WARN: The directory $PATCH_DIR is not available"; 
                             if ping -c 1 -w 2 "$NFS_SHARE_01_ADDR" >/dev/null; then mount -t cifs -o username=$SHARE_USER_NAME,pass=$NFS_SHARE_PWD "$NFS_SHARE_01_PATH" "$SHARE_MOUNT_POINT" >/dev/null; check_exitcode
                                                                                     echo "INFO: NFS itoshare-nek mounted"; array00[$TASK_NUMBER]="[$EXIT_CODE] mount itoshare"; fi
                             if ping -c 1 -w 2 "$NFS_SHARE_02_ADDR" >/dev/null; then mount -t cifs -o username=$SHARE_USER_NAME,pass=$NFS_SHARE_PWD "$NFS_SHARE_02_PATH" "$SHARE_MOUNT_POINT" >/dev/null; 
                                                                                     echo "INFO: NFS itoshare-nsu mounted"; array00[$TASK_NUMBER]="[$EXIT_CODE] mount itoshare"; fi; fi


# sapadm password check [2]
#clear
#print_array00
#echo "Check user sapadm password:"
#while true; do echo;
#               echo "  1 -> check sapadm user password"
#               echo "  c -> continue"
#               echo "  b -> go to the main menu"
#               read -p "Select: " yn
#               case "$yn" in 1) su "$sybase_user" -c "su sapadm"; check_exitcode; array00[2]="[manually] sapadm password check";;
#                             c) break;;
#                             b) set_page; esac; done




# Hostagent update 
TASK_NUMBER=$((TASK_NUMBER+1))
clear
print_array00
HOSTAGENT_PATCH_STAND=$(/usr/sap/hostctrl/exe/saphostexec -version | grep 'patch number')
HOST_AGENT_PATCH=$(ls -1 $HOST_AGENT_PATH/SAPHOSTAGENT*.SAR | sort | tail -1)
echo "INFO: The hostagent can be updated to the last version from ${BOLD}$HOST_AGENT_PATCH${RESTORE}"

while true; do echo;
               echo "STEP $TASK_NUMBER: Update of the of the Hostagent: ${YELLOW}$HOSTAGENT_PATCH_STAND${RESTORE} $EXIT_CODE_TEXT" 
               echo "  1 -> Update HOSTAGENT with a patch: $HOST_AGENT_PATCH"
               echo "  c -> continue"
               echo "  b -> go to the main menu"
               read -p "Select: " yn
               case "$yn" in 1) /usr/sap/hostctrl/exe/saphostexec -upgrade -archive "$HOST_AGENT_PATCH" > /dev/null; check_exitcode; array00[$TASK_NUMBER]="[$EXIT_CODE] SAP Hostagent update"
                                echo "Check the results and if satisfied, you can continue";;
                             c) break;;
                             b) set_page; esac; done
                          
#echo "INFO: Current patch level of Hostagent: ${GREEN}$HOSTAGENT_PATCH_STAND${RESTORE}"

# Save ASE parameters in log
TASK_NUMBER=$((TASK_NUMBER+1))
clear
print_array00
check_ase_root
echo "INFO: All parameter will be saved in the log-file as output from 'sp_configure':"
while [ "$check_ase_status" == 0 ]; do echo "INFO: ASE instance ${YELLOW}$SYBASE_SID is not running ${RESTORE}. It will be started now...";
                                                                     ask_proceed_yn;
                                                                     startdb_root;
                                                                     pause
                                                                     check_ase_root; done
isql_request_nocolumns_verbose_root "sp_configure";
array00[$TASK_NUMBER]="[SUCCESS] save ASE parameters in log"



# Patch selection
TASK_NUMBER=$((TASK_NUMBER+1))
clear
print_array00
echo "INFO: Current ASE Version of the $SYBASE_SID: ${BOLD}$ase_version${RESTORE}"
old_ase_version="$ase_version"
echo "STEP $TASK_NUMBER: Available ASE patches on $PATCH_DIR:"
PATCH_DIR_LIST=$(ls -1t "$PATCH_DIR" | sort); PATCH_DIR_LIST=($PATCH_DIR_LIST)
counter=1
for i in ${!PATCH_DIR_LIST[*]}; do printf "%4d "\-\>" %s\n" $counter ${PATCH_DIR_LIST[$i]}; ((counter++)); done
echo
while [[ -z $index ]] || [[ $index -le 0 ]] || [[ $index -gt ${#PATCH_DIR_LIST[@]} ]]; do read -p "Select patch: " index; done
((index--))
PATCH_VERSION="${PATCH_DIR_LIST[$index]}"
echo "Selected: $PATCH_VERSION"
PATCH_DIR="$PATCH_DIR/${PATCH_DIR_LIST[$index]}"
PATCH_DBCLIENT="$PATCH_DIR/$DB_CLIENT_PATCH"
PATCH_DBPATCH="$PATCH_DIR/$DB_PATCH"
SYB_UPDATE_DB_FILE="$ASEUP_PATH/$SYB_UPDATE_DB_FILE"
array00[$TASK_NUMBER]="[SUCCESS] ASE patch version: $PATCH_VERSION"

# Software & Prereqs. checks
TASK_NUMBER=$((TASK_NUMBER+1))
clear
print_array00
if [ ! -e "$PATCH_DBPATCH" ]; then echo "ERROR: The file $PATCH_DBPATCH not available. Check it."; set_page; fi 
if [ ! -e "$SYB_UPDATE_DB_FILE" ]; then echo "ERROR: The file $SYB_UPDATE_DB_FILE not available. Check it."; set_page; fi
if [ ! -e "$PATCH_DBCLIENT" ]; then echo "ERROR: The file $PATCH_DBCLIENT not available. Check it."; set_page; fi

echo
while true; do echo "STEP $TASK_NUMBER:Check prerequisites before the patch installation:" 
               echo "  1 -> start check (as user sapadm)"
               echo "  c -> continue"
               echo "  b -> go to the main menu"
               read -p "Select: " yn
               case "$yn" in 1) su "$sybase_user" -c "/usr/sap/hostctrl/exe/saphostctrl -user sapadm - -function LiveDatabaseUpdate -dbname $SYBASE_SID -dbtype syb -updatemethod Check -updateoption TASK=CHECK_UPDATE_ASE -updateoption DROP_LOCATION=${PATCH_DIR}"; check_exitcode;
                                echo "Check the results and if satisfied, you can continue"; check_exitcode; array00[$TASK_NUMBER]="[$EXIT_CODE] Software & Prereqs. checks";;
                             c) break;; 
                             b) set_page; esac; done 
                

# +++ DOWNTIME PHASE +++
TASK_NUMBER=$((TASK_NUMBER+2))
clear
print_array00
echo "${RED}DOWNTIME PHASE:${RESTORE}"
# Stop patrol agent [8]
while true; do echo;
               echo "STEP $TASK_NUMBER: Stopping the patrol agent" 
               echo "  1 -> stop agent"
               echo "  c -> continue"
               echo "  b -> go to the main menu"
               read -p "Select: " yn
               case "$yn" in 1) /etc/init.d/patrol stop; 
                                check_exitcode; array00[$TASK_NUMBER]="[$EXIT_CODE] Stopping patrol agent" 
                                echo "Check the results and if satisfied, you can continue";;
                             c) break;; 
                             b) set_page; esac; done 
 





# SAPCAR
#FREE_SPACE=$(df -m /tmp | egrep -v Filesyst| awk '{ print $1 }' | tr -d ' '); 
#while [[ "$PATCH_DBPATCH_SIZE" > "$FREE_SPACE" ]]; do echo "${YELLOW}WARNING: $PATCH_DIR_UNPACK too small for unpacked patch. Free space: ${FREE_SPACE}MB${RESTORE}"; 
#                                                                  read -p "Enter another directory as destination (e.g. $SYBASE/ASE_PATCH_$CTIME): " PATCH_DIR_UNPACK
#                                                                  while [ ! -d "$PATCH_DIR_UNPACK" ]; do echo "${YELLOW}WARNING: The directory not exist${RESTORE}. Create it or"; read -p "enter another directory as destination: " PATCH_DIR_UNPACK; done
#                                                                  #FREE_SPACE=$(df -m $PATCH_DIR_UNPACK | egrep -v Filesystem | awk '{ print $4 }');
#                                                                  FREE_SPACE=$(df -m $PATCH_DIR_UNPACK | egrep -v Filesystem | awk '{ print $4 }'); 
#                                                                  if [ "$FREE_SPACE" > "$PATCH_DBPATCH_SIZE" ]; then break; fi; done
#while True; do if [ "$PATCH_DBPATCH_SIZE" > "$FREE_SPACE" ]; then echo "${YELLOW}WARNING: $PATCH_DIR_UNPACK too small for unpacked patch. Free space: ${FREE_SPACE}MB${RESTORE}";
#                                                   read -p "Enter another directory as destination (e.g. $SYBASE/ASE_PATCH_$CTIME): " PATCH_DIR_UNPACK
#                                                   while [ ! -d "$PATCH_DIR_UNPACK" ]; do echo "WARNING: The directory not exist"; read -p "Enter another directory as destination: " PATCH_DIR_UNPACK; done
#                                                   FREE_SPACE=$(df -m $PATCH_DIR_UNPACK | egrep -v Filesystem | awk '{ print $4 }');
#                                                                            
#echo "INFO: The patch ${GREEN}$PATCH_VERSION${RESTORE} will be extracted to ${BOLD}$PATCH_DIR_UNPACK${RESTORE}"; 
#ask_proceed_yn;
#"$SAPCAR" -xvf "$PATCH_DBPATCH" -R "$PATCH_DIR_UNPACK"; 
#
#cp -v "$ASEUP_PATH/$ASEUP_FILE" "$PATCH_DIR_UNPACK";  
#cp -v "$SYB_UPDATE_DB_FILE" "$PATCH_DIR_UNPACK";



# Stop SAP & ASE
TASK_NUMBER=$((TASK_NUMBER+1))
clear
print_array00
check_java
check_abap
echo "INFO: $sap_abap_status_text | $sap_java_status_text";
while [ "$sap_abap_status" == 1 -o "$sap_java_status" == 1 ]; do echo "SAP application ${GREEN}$SYBASE_SID${RESTORE} will be stopped automatically now. Set a blackout.";
                                                                 ask_proceed_yn;
                                                                 stopsap; done

echo
check_ase_root
while [ "$check_ase_status" == 1 -o "$check_dbase_status" == 1 ]; do echo "ASE instance ${GREEN}$SYBASE_SID${RESTORE} will be stopped automatically now.";
                                                                     ask_proceed_yn;
                                                                     stopdb_root;
                                                                     check_ase_root; done


# Save current /sybase to backup server
TASK_NUMBER=$((TASK_NUMBER+1))
clear
print_array00
while true; do echo;
               echo "STEP $TASK_NUMBER: Saving of the current /sybase directory to backup-server:" 
               echo "  1 -> start the backup"
               echo "  c -> continue"
               echo "  b -> go to the main menu"
               read -p "Select: " yn
               case "$yn" in 1) save -s ${BACKUP_SERVER} -l Full -e Month -b Filesystem -N ${HOSTNAME}_sybase_${SYBASE_SID} ${SYBASE}; 
                                check_exitcode; array00[$TASK_NUMBER]="[$EXIT_CODE] Saving of the current /sybase directory to backup-server";
                                echo "Check the results and if satisfied, you can continue";;
                             c) break;; 
                             b) set_page; esac; done 
# Start server again
TASK_NUMBER=$((TASK_NUMBER+1))
clear
print_array00
while [ "$sap_abap_status" == 0 -o "$sap_java_status" == 0 ]; do echo; echo "INFO: $sap_abap_status_text | $sap_java_status_text";
                     echo "INFO: $check_ase_text | $check_dbase_text"
               echo "STEP: Start ASE/BS again" 
               echo "  1 -> start ASE Server"
               echo "  b -> go to the main menu"
               read -p "Select: " yn
               case "$yn" in 1) startdb_root; check_ase_root; #echo "INFO: $sap_abap_status_text | $sap_java_status_text";
                                check_exitcode; array00[$TASK_NUMBER]="[$EXIT_CODE] ASE started";
                                echo "Check the results and if satisfied, you can continue"; break;; 
                             b) set_page; esac; done 
                             
# Backup the latest database logs (recall script or via DasiWeb)
TASK_NUMBER=$((TASK_NUMBER+1))
clear
print_array00
while true; do echo;
               echo "STEP $TASK_NUMBER: Backup the latest database logs" 
               echo "  1 -> start backup with ${SYBASE_SID}_archive_recall.sh"
               echo "  c -> continue"
               echo "  b -> go to the main menu"
               read -p "Select: " yn
               case "$yn" in 1) /nsr/apps/config/${SYBASE_SID}_archive_recall.sh; 
                                check_exitcode; array00[$TASK_NUMBER]="[$EXIT_CODE] ";
                                echo "Check the results and if satisfied, you can continue";;
                             c) break;; 
                             b) set_page; esac; done 

                             
# Check prerequisites
TASK_NUMBER=$((TASK_NUMBER+1))
clear
print_array00
while true; do echo;
               echo "STEP $TASK_NUMBER: Check prerequisites before the patch installation:" 
               echo "  1 -> start check (as user sapadm)"
               echo "  c -> continue"
               echo "  b -> go to the main menu"
               read -p "Select: " yn
               case "$yn" in 1) su "$sybase_user" -c "/usr/sap/hostctrl/exe/saphostctrl -user sapadm - -function LiveDatabaseUpdate -dbname $SYBASE_SID -dbtype syb -updatemethod Check -updateoption TASK=CHECK_UPDATE_ASE -updateoption DROP_LOCATION=${PATCH_DIR}"; 
                                check_exitcode; array00[$TASK_NUMBER]="[$EXIT_CODE] ";
                                echo "Check the results and if satisfied, you can continue";;
                             c) break;; 
                             b) set_page; esac; done 

# Update ASE Software
TASK_NUMBER=$((TASK_NUMBER+1))
clear
print_array00
while true; do echo;
               echo "STEP $TASK_NUMBER: Update ASE Server (Selected patch: ${BOLD}$PATCH_DIR${RESTORE})" 
               echo "  1 -> start update"
               echo "  c -> continue"
               echo "  b -> go to the main menu"
               read -p "Select: " yn
               case "$yn" in 1) echo "INFO: Check the update process logs: tail -f /usr/sap/hostctrl/work/LiveUpdate.log"
                                echo "INFO: Check the sapdbctrl proc. log: tail -f /usr/sap/hostctrl/work/dev_sapdbctrl"
                                /usr/sap/hostctrl/exe/saphostctrl -user sapadm - -function LiveDatabaseUpdate -dbname $SYBASE_SID -dbtype syb -updatemethod Execute -updateoption TASK=UPDATE_ASE -updateoption DROP_LOCATION="${PATCH_DIR}"; 
                                check_exitcode; array00[$TASK_NUMBER]="[$EXIT_CODE] ";
                                echo "Check the results and if satisfied, you can continue";;
                             c) break;; 
                             b) set_page; esac; done 


#chmod 750 "$PATCH_DIR_UNPACK/$ASEUP_FILE"
#chown "$sybase_user" "$PATCH_DIR_UNPACK/$ASEUP_FILE"


#echo "Please select the update mode for ASEup.sh: "
#echo " [${BOLD}n${RESTORE}]ormal installation (default)"
#echo " [${BOLD}s${RESTORE}]kip installation and execute only post-istallation actions: ${BOLD}DNO_INSTALL${RESTORE}"
#echo " [${BOLD}r${RESTORE}]einstall ASE. Useful after previous update cancellation/errors: ${BOLD}DREINSTALL${RESTORE}"
#echo " [s]kip ASEup.sh execution"
#echo " [b]ack, cancel the update"
#while true; do read -p "Select [n/s/r/b]: " yn 
#               case "$yn" in n) ASEUPDATE_COMMAND="./$ASEUP_FILE"; break;;
#                             s) ASEUPDATE_COMMAND="./$ASEUP_FILE -DNO_INSTALL"; break;;
#                             r) ASEUPDATE_COMMAND="./$ASEUP_FILE -DREINSTALL"; break;;
#                             b) continue;; esac; done
                             
#PATH=$PATH:$PATCH_DIR_UNPACK                             
#su "$sybase_user" -c \"$ASEUPDATE_COMMAND\"
#if [ ! -z "$ASEUPDATE_COMMAND" ]; then CURRENT_PWD=$(pwd);
#                                       par55=$(xauth list $DISPLAY)
#                                       #su "$sybase_user" -c "xauth add $par55 && cd $PATCH_DIR && $ASEUPDATE_COMMAND && cd $CURRENT_PWD"; fi
#                                       chown -R "$sybase_user":sapsys "$PATCH_DIR_UNPACK"
#                                       #su "$sybase_user" -c "xauth add $par55 && cd $PATCH_DIR_UNPACK && $ASEUPDATE_COMMAND && cd $CURRENT_PWD"; fi
#                                       echo "INFO: You can trace the log files in another putty session with: ${BOLD}${GREEN}$CURRENT_PWD/$0 log_monitor $SYBASE/log${RESTORE}"
#                                       su "$sybase_user" -c "cd $PATCH_DIR_UNPACK && $ASEUPDATE_COMMAND && cd $CURRENT_PWD"; fi
#
#su "$sybase_user" -c "cd $PATCH_DIR_UNPACK && pwd && cd $CURRENT_PWD && pwd"
#(cd /tmp && pwd)

# Perform post-upgrade tasks.(1598817 - SYB: Removal of sample client library applications)
#echo
#chmod -R g-w,o-rwx "${SYBASE}"
#if grep "umask 027" "$SYBASE"/.profile >/dev/null; then echo "INFO: File $SYBASE/.profile contains 'umask 027'"
#                                                   else echo "umask 027" >> "$SYBASE"/.profile; fi 

# Sample directories deletion
#echo
#SAMPLE_DIR_01="$SYBASE/OCS-16_0/sample"
#SAMPLE_DIR_02="$SYBASE/DataAccess/ODBC/samples"
#SAMPLE_DIR_03="$SYBASE/jConnect-7_0/sample2"
#SAMPLE_DIR_04="$SYBASE/jConnect-7_0/classes/sample2"
#SAMPLE_DIR_05="$SYBASE/ASE-16_0/sample"
#SAMPLE_DIR_06="$SYBASE/WS-16_0/samples"
#if [ -d "$SAMPLE_DIR_01" ]; then rm -rv "${$SAMPLE_DIR_01:?}"; echo "INFO: Sample directory deleted: $SAMPLE_DIR_01"; else echo "INFO: No sample directory found: $SAMPLE_DIR_01"; fi
#if [ -d "$SAMPLE_DIR_02" ]; then rm -rv "${$SAMPLE_DIR_02:?}"; echo "INFO: Sample directory deleted: $SAMPLE_DIR_02"; else echo "INFO: No sample directory found: $SAMPLE_DIR_02"; fi
#if [ -d "$SAMPLE_DIR_03" ]; then rm -rv "${$SAMPLE_DIR_03:?}"; echo "INFO: Sample directory deleted: $SAMPLE_DIR_03"; else echo "INFO: No sample directory found: $SAMPLE_DIR_03"; fi
#if [ -d "$SAMPLE_DIR_04" ]; then rm -rv "${$SAMPLE_DIR_04:?}"; echo "INFO: Sample directory deleted: $SAMPLE_DIR_04"; else echo "INFO: No sample directory found: $SAMPLE_DIR_04"; fi
#if [ -d "$SAMPLE_DIR_05" ]; then rm -rv "${$SAMPLE_DIR_05:?}"; echo "INFO: Sample directory deleted: $SAMPLE_DIR_05"; else echo "INFO: No sample directory found: $SAMPLE_DIR_05"; fi
#if [ -d "$SAMPLE_DIR_06" ]; then rm -rv "${$SAMPLE_DIR_06:?}"; echo "INFO: Sample directory deleted: $SAMPLE_DIR_06"; else echo "INFO: No sample directory found: $SAMPLE_DIR_06"; fi
#
#rm -rf "$PATCH_DIR_UNPACK"/archives

# Update the ODBC and JDBC drivers.
clear
print_array00
while true; do echo "STEP $TASK_NUMBER: Update the ODBC/JDBC drivers (Selected patch: ${BOLD}$PATCH_DBCLIENT${RESTORE})" 
               echo "  1 -> start update"
               echo "  c -> continue"
               echo "  b -> go to the main menu"
               read -p "Select: " yn
               case "$yn" in 1) SAPCAR -xvf "$PATCH_DBCLIENT" -R "$OJDBC_DIR"; 
                                check_exitcode; array00[$TASK_NUMBER]="[$EXIT_CODE] ";  
                                echo "Check the results and if satisfied, you can continue";;
                             c) break;; 
                             b) set_page; esac; done 




#echo
#if [ -d "$OJDBC_DIR" ]; then rsync -ap "$OJDBC_DIR" "$OJDBC_DIR_BKP"; echo "INFO: Backup of the $OJDBC_DIR done to ${BOLD}$OJDBC_DIR_BKP${RESTORE}";
#                             if SAPCAR -xvf "$PATCH_DBCLIENT" -R "$OJDBC_DIR"; then echo "INFO: JDBC/ODBC drivers updated"; 
#                                                                               else echo "ERROR: JDBC/ODBC drivers not updated!"; fi 
#                        else echo "INFO: The directory $OJDBC_DIR doesn't exist. Skipped."; fi
  
# Start DB & SAP
print_array00
server_version_root
echo "${GREEN}INFO: Update process finish!${RESTORE}"
echo "INFO: ASE Version before update: ${BOLD}$old_ase_version${RESTORE}"
echo "INFO: ASE Version after  update: ${BOLD}$ase_version${RESTORE}"
echo "INFO: $sap_abap_status_text | $sap_java_status_text";

#ask_proceed_yn
#startdb_root
#check_ase_root 
END=$(date +%s)
DIFF=$(( $END - $START ))
DIFF=$(( $DIFF / 60 ))
echo "INFO: The update took $DIFF minutes." 

#if [ "$check_ase_status" == 1 ] && [ "$check_dbase_status" == 1 ]; then echo "INFO: $check_ase_text/$check_dbase_text"; 
#
 
#echo "INFO: S"
#ask_proceed_yn

set_page
}


log_monitor(){
echo "ASE Update Log Monitor of the directory $LOG_DIR:"

array00=( $( ls -alt $LOG_DIR ) )
array01="${#array00[@]}"
while ps -ef | grep ASEup.sh | egrep -v grep >/dev/null; do array00=( $( ls -alt $LOG_DIR ) ); array03="${#array00[@]}"
               if [ $array01 -eq  $array03 ]; then sleep 5;
                                              else echo "INFO: New log-file ${BOLD}$(ls -1t $LOG_DIR | head -n 1)${RESTORE} araised at $(date)";
                                                   array01="$array03"; fi; done

echo "INFO: No OS-process ASEup.sh found. Exit."
exit 0
}

###################################################################### MENU ELEMENTS ####################################################################
shotcuts_text(){
echo "Standart keys: ${BOLD}s${RESTORE} - stop, ${BOLD}sql${RESTORE} - open iSQL, ${BOLD}vi${RESTORE} - edit RUN_${SYBASE_SID}, ${BOLD}alog${RESTORE} - tail ${SYBASE_SID}.log, ${BOLD}less${RESTORE} - less ${SYBASE_SID}.log, ${BOLD}blog${RESTORE} - tail ${SYBASE_SID}_BS.log"
echo "               ${BOLD}jlog${RESTORE} - read ${SYBASE_SID}_JSAGENT.log, ${BOLD}locks${RESTORE} - syslocks, ${BOLD}act${RESTORE} - active sessions, ${BOLD}all${RESTORE} - all sessions"
echo "               ${BOLD}dbspace${RESTORE} - DB sizes, ${BOLD}devs${RESTORE} - devices, ${BOLD}mem${RESTORE} - memory consumption"
echo "               ${BOLD}dbid${RESTORE} - get db_id, ${BOLD}objid${RESTORE} - get object_name"
}

shotcuts_text_root(){
echo "Standart keys: ${BOLD}s${RESTORE} - stop, ${BOLD}sql${RESTORE} - open iSQL, ${BOLD}vi${RESTORE} - edit RUN_${SYBASE_SID}, ${BOLD}alog${RESTORE} - tail ${SYBASE_SID}.log, ${BOLD}less${RESTORE} - less ${SYBASE_SID}.log, ${BOLD}blog${RESTORE} - tail ${SYBASE_SID}_BS.log"
echo "               ${BOLD}jlog${RESTORE} - read ${SYBASE_SID}_JSAGENT.log, ${BOLD}locks${RESTORE} - syslocks, ${BOLD}act${RESTORE} - active sessions, ${BOLD}all${RESTORE} - all sessions"
echo "               ${BOLD}dbspace${RESTORE} - DB sizes, ${BOLD}devs${RESTORE} - devices, ${BOLD}mem${RESTORE} - memory consumption"
echo "               ${BOLD}dbid${RESTORE} - get db_id, ${BOLD}objid${RESTORE} - get object_name"
}


shotcuts_text_short(){
echo "Standart keys: s - stop, b - back, sql - open iSQL"
}


shortcuts(){
if [ "$answer" == "sql" ]; then isql_user_session;
   elif [ "$answer" == "vi" ]; then vi "$run_file";
   elif [ "$answer" == "less" ]; then more "$alert_log" | less;
   elif [ "$answer" == "alog" ]; then read_alert_log;
   elif [ "$answer" == "blog" ]; then read_alert_log_bkp;
   elif [ "$answer" == "jlog" ]; then read_jsagent_log;
   elif [ "$answer" == "locks" ]; then sql_syslocks;
   elif [ "$answer" == "act" ]; then isql_active_sessions;
   elif [ "$answer" == "all" ]; then isql_all_sessions;
   elif [ "$answer" == "s" ]; then print_exit;
   elif [ "$answer" == "m" ]; then print_main;
   elif [ "$answer" == "dbid" ]; then get_db_id;
   elif [ "$answer" == "objid" ]; then get_object_id;
   elif [ "$answer" == "dbspace" ]; then data_log_sizes_all;
   elif [ "$answer" == "devs" ]; then show_devices;
   elif [ "$answer" == "mem" ]; then show_memory;
   #elif [ "$answer" == "bash" ]; then /bin/bash;
   else echo "${RED}Unknown choice.${RESTORE} Check it or press 'm' to display the current menu. ${RESTORE}"; fi
}

shortcuts_root(){
if [ "$answer" == "sql" ]; then isql_user_session_root;
   elif [ "$answer" == "vi" ]; then vi "$run_file";
   elif [ "$answer" == "less" ]; then more "$alert_log" | less;
   elif [ "$answer" == "alog" ]; then read_alert_log;
   elif [ "$answer" == "blog" ]; then read_alert_log_bkp;
   elif [ "$answer" == "jlog" ]; then read_jsagent_log;
   #elif [ "$answer" == "locks" ]; then sql_syslocks;
   #elif [ "$answer" == "act" ]; then isql_active_sessions;
   #elif [ "$answer" == "all" ]; then isql_all_sessions;
   elif [ "$answer" == "s" ]; then print_exit;
   elif [ "$answer" == "m" ]; then print_main_root;
   #elif [ "$answer" == "dbid" ]; then get_db_id;
   #elif [ "$answer" == "objid" ]; then get_object_id;
   #elif [ "$answer" == "bash" ]; then /bin/bash;
   elif [ "$answer" == "dbspace" ]; then data_log_sizes_all;
   elif [ "$answer" == "devs" ]; then show_devices;
   else echo "${RED}Unknown choice.${RESTORE} Check it or press 'm' to display the current menu. ${RESTORE}"; fi
}


check_abap(){
if ps -ef | grep dw.sap | grep ${SYBASE_SID} | egrep -v grep > /dev/null; then sap_abap_status=1; sap_abap_status_text="ABAP ${BOLD}${GREEN}online${RESTORE}"
                                                                          else sap_abap_status=0; sap_abap_status_text="ABAP ${BOLD}${RED}offline${RESTORE}"; fi
}

check_java(){
if ps -ef | grep jstart | grep ${SYBASE_SID} | egrep -v grep > /dev/null; then sap_java_status=1; sap_java_status_text="Java ${BOLD}${GREEN}online${RESTORE}"
                                                                          else sap_java_status=0; sap_java_status_text="Java ${BOLD}${RED}offline${RESTORE}"; fi
}

menu_separator(){
echo "----------------------------------------------------------------------------------------------------------------------------------------------------------"
}

######################################################################## MENU PAGES ########################################################################
print_main_root(){
unset_temp_vars
setpage="${FUNCNAME[0]}"
server_version_root
top_info_root 
menu_separator 
echo "Main menu                                ${YELLOW}WARNING! You have started the script as a superuser. This mode should be used only for ASE server update/upgrade!${RESTORE}"
echo
echo "1 - Installing Service Packs for SAP ASE"
echo "2 - Performing a major ASE upgrade [SAP Note: 2162715]"
echo "3 - Start ASE"
echo "4 - Stop ASE"
echo "5 - Start SAP $SYBASE_SID"
echo "6 - Stop SAP $SYBASE_SID"
echo "7 - "
echo "8 - "
echo "9 - Custom functions"
echo
shotcuts_text
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  ase_update;;
                    #2)  ase_upgrade;;
                    3)  startdb_root_menu;;
                    4)  stopdb_root_menu;;
                    5)  startsap_menu;;
                    6)  stopsap_menu;;
                    7)  ;;
                    8)  ;;
                    9)  ;;
                    *) shortcuts_root;; esac; done
}

print_main(){
unset_temp_vars
setpage="${FUNCNAME[0]}"
server_version
top_info 
menu_separator
echo "Main menu"
echo
echo "1 - Instance management"
echo "2 - Space management"
echo "3 - Segment management"
echo "4 - Backup and database copy"
echo "5 - Restore and recovery"
echo "6 - Check and verification"
echo "7 - Database statistic"
echo "8 - Additional functions"
echo "9 - Custom functions"
echo
shotcuts_text
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  print_01;;
                    2)  print_02;;
                    3)  print_03;;
                    4)  print_04;;
                    5)  print_05;;
                    6)  print_06;;
                    7)  print_07;;
                    8)  print_08;;
                    9)  print_09;;
                    *) shortcuts;; esac; done
}


print_01(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Database instance management"
echo 
echo "0 - Start/stop backup server"
echo "1 - Start up database and backup server"
echo "2 - Shut down database and backup sever"
echo "3 - Turn the database to other modes"
echo "4 - Alter database instance"
echo "5 - Alter database parameter"
echo "6 - Recreate database"
echo "7 - Manage online redologs"
echo "8 - Manage data ecnryption"
echo "9 - Manage db-sessions"
echo "10 - Manage trace flags"
echo "11 - Additional instance functions"
echo 
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
		   			        m)  set_page;;
                    0)  print_01_00;;
                    1)  startdb;;
                    2)  stopdb;;
                    3)  print_01_03;;
                    4)  ;;
                    5)  ;;
                    6)  ;;
                    7)  ;;
		                8)  ;;
                    9)  print_01_09;;
		                10) print_01_10;;
            		    11) print_01_11;;
                    b)  print_main;;
                    *) shortcuts;; esac; done
}



print_02(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Database space management"
echo
echo "1 - Extend data/log device"
echo "2 - Create new device"
echo "3 - Drop device"
echo "4 - Schrink log-device"
echo "5 - Alter data file"
echo "6 - Move data file"
echo "7 - Additional space functions"
echo 
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  print_02_01;;
                    2)  print_02_02;;
                    3)  isql_drop_device;;
                    4)  isql_schrink_logdev;;
                    5)  ;;
                    6)  isql_move_data_file;;
                    7)  print_02_07;;
                    b)  print_main;;
                    *) shortcuts;; esac; done
}

print_03(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Database segment management"
echo
echo "1 - Reorganize tables"
echo "2 - Rebuild indexes"
echo "3 - Export tables"
echo "4 - Import tables"
echo "5 - Alter tables"
echo "6 - Alter indexes"
echo "7 - Additional segment functions"
echo 
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1) isql_table_reorg_mass;;
                    2) isql_idx_reorg;;
                    3) bcp_table_export;;
                    4) ;;
                    5) ;;
                    6) ;;
                    7) ;;
                    b) print_main;;
                    *) shortcuts;; esac; done
}

print_04(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Backup and database copy"
echo
echo "1 - Database backup"
echo "2 - Archivelog backup"
echo "3 - Database copy"
echo "4 - Non-database backup"
echo "5 - Backup of database disk backup"
echo "6 - Verification of database backup"
echo "7 - Verification of archivelog backup"
echo "8 - Additional functions"
echo 
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  print_04_01;;
                    2)  ;;
                    3)  ;;
                    4)  ;;
                    5)  ;;
                    6)  ;;
                    7)  ;;
                    8)  ;;
                    b)  print_main;;
                    *) shortcuts;; esac; done
}

print_05(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Restore and recovery"
echo
echo "1 - Complete database recovery"
echo "2 - Database point-in-time recovery"
echo "3 - Tablespace point-in-time recovery"
echo "4 - Whole database reset"
echo "5 - Restore of individual backup files"
echo "6 - Restore and application of archivelog files"
echo "7 - Disaster recovery"
echo "8 - Manage flashback database"
echo 
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  ;;
                    2)  ;;
                    3)  ;;
                    4)  ;;
                    5)  ;;
                    6)  ;;
                    7)  ;;
                    b)  print_main;;
                    *) shortcuts;; esac; done
}

print_06(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Database check and verification"
echo
echo "1 - Database system check"
echo "2 - Validation of database structures"
echo "3 - Verification of database blocks"
echo 
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  ;;
                    2)  print_06_02;;
                    3)  ;;
                    b)  print_main;;
                    *) shortcuts;; esac; done
}

print_07(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Processing database statistics"
echo 
echo "1 - Update database statistics"
echo "2 - Collect missing statistics"
echo "3 - Delete harmful statistics"
echo "4 - Manage database statistics"
echo "5 - Collect dictionary statistics"
echo "6 - Collect system statistics"
echo 
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  print_07_01;;
                    2)  ;;
                    3)  print_07_03;;
                    4)  ;;
                    5)  ;;
                    6)  ;;
                    7)  ;;
                    b)  print_main;;
                    *)  shortcuts;; esac; done
}


print_08(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Additional ASETools functions"
echo 
echo "1 - Show profiles and logs"
echo "2 - Clean up DBA logs and tables"
echo "3 - Adapt NEXT extents"
echo "4 - Change password of database user"
echo "5 - Create/change synonyms for DBA tables"
echo
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  ;;
                    2)  ;;
                    3)  ;;
                    4)  ;;
                    5)  ;;
                    b)  print_main;;
                    *)  shortcuts;; esac; done
}

print_09(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Custom functions"
echo 
echo "0 - Compress script log files of this instance"
echo "1 - Unlock ABAP-user"
echo "2 - Change SID in logthresholds after systemcopies to new SID [syscopy_adapt_logthresholds_sid.sql]"
echo "3 - Test Programm"
echo "4 - isql_sap_sessions"
echo "5 - "
echo "6 - "
echo "7 - "
echo 
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    0)  zip_log_files;;
                    1)  unlock_abap_user;;
                    2)  syscopy_adapt_logthresholds_sid;;
                    3)  print_dbcc_traceflags;;
                    4)  isql_sap_sessions;;
                    5)  ;;
                    6)  ;;
                    7)  ;;
                    b)  print_main;;
                    *)  shortcuts;; esac; done
}


print_01_00(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Start/Stop backup server"
echo
echo "1 - Start the backup server"
echo "2 - Stop the backup server"
echo 
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  start_backup_server;;
                    2)  stop_backup_server;;
                    b)  print_01;;
                    *)  shortcuts;; esac; done
}

print_01_03(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Other modes for the database"
echo
echo "1 - Start up the database in Single-User mode"
echo "2 - Put specific database in Single-User mode"
echo "3 - Return specific database in Single-User mode"
echo "4 - De-activate the Prepare-Mode [${CYAN}Hint: Puts the affected database into prepare mode which enables creation of a 'split mirror' copy of the database]${RESTORE}"
echo "5 - De-activate the Quiesce-Mode [${CYAN}Hint: Block updates to one or more databases while you perform a disk unmirroring or external copy of each database device]${RESTORE}"
echo "6 - Switch the database to noarchive mode or back"
echo 
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  startdb_single;;
                    2)  put_db_to_single;;
                    3)  put_db_from_single;;
                    4)  print_01_03_04;;
                    5)  print_01_03_05;;
                    6)  archive_mode;;
                    b)  print_01;;
                    *)  shortcuts;; esac; done
}

print_01_03_04(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Database Preparation Mode"
echo 
echo "1 - Show if the Prepare-Mode active"
echo "2 - Activate the Prepare-Mode"
echo "3 - Deactivate the Prepare-Mode"
echo 
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1) show_prep_mode;;
                    2) act_prep_mode;;
                    3) deact_prep_mode;;
                    b)  print_01_03;;
                    *) shortcuts;; esac; done
}


print_01_03_05(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "The Quiesce-Mode options"
echo 
echo "1 - Activate the Quisce-Mode"
echo "2 - Deactivate the Quisce-Mode"
echo 
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  act_qui_mode;;
                    2)  deact_qui_mode;;
                    b)  print_01_03;;
                    *) shortcuts;; esac; done
}

print_01_09(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Database session functions"
echo 
echo "1 - Show/kill active sessions"
echo "2 - Show running sessions"
echo 
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1) isql_sp_who;;
                    2) isql_active_sessions;;
                    b) print_01;;
                    *) shortcuts;; esac; done
}


print_01_10(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Trace flags [de-]activation functions"
echo 
echo "1 - Activate trace flag ${MAGENDA}[All available Trace Flags: https://wiki.scn.sap.com/wiki/display/SYBASE/ASE+Traceflags]${RESTORE}"
echo "2 - Deactivate trace flag"
echo
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  dbcc_traceon;;
                    2)  dbcc_traceoff;;
                    b)  print_01;;
                    *) shortcuts;; esac; done
}

print_01_11(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Additional database instance functions"
echo
echo "1 - Show component version"
echo "2 - Show data and log sizes"
echo "3 - Show database options & parameters"
echo "4 - Show database owners"
echo "5 - Show flashback status"
echo "6 - Show encryption status"
echo "7 - Show wait events"
echo "8 - Show memory usage"
echo "9 - Show active processes"
echo
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1) sp_version;;
                    2) data_log_sizes_all;;
                    3) isql_show_db_options;;
                    4) isql_show_db_users;;
                    5) ;;
                    6) ;;
                    7) isql_mon_wait_event_info;;
                    8) isql_mon_memory_usage;;
                    9) isql_sysprocesses;;
                    b) print_01;;
                    *) shortcuts;; esac; done
}

print_02_01(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Data/log device extension"
echo
echo "1 - Show space scope free/used space in the databases"
echo "2 - Show devices info"
echo "3 - Resize ${BOLD}data${RESTORE}-device"
echo "4 - Resize ${BOLD}log${RESTORE}-device"
echo
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  data_log_sizes_all;;
                    2)  show_devices;;
                    3)  resize_data_dev_new;;
                    4)  resize_log_dev;;
                    b)  print_02;;
                    *) shortcuts;; esac; done
}

print_02_02(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Create new device"
echo
echo "1 - Create new ${BOLD}data${RESTORE}-devices"
echo "2 - Create new ${BOLD}log${RESTORE}-device"
echo "3 - Create new ${BOLD}dump${RESTORE}-device"
echo
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  create_new_devs_wiz;;
                    2)  create_new_log_dev_wiz;;
                    3)  create_new_dmp_dev_wiz;;
                    b)  print_02;;
                    *) shortcuts;; esac; done
}

print_02_07(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Additional space functions"
echo
echo "1 - Show the biggest N tables"
echo "2 - "
echo "3 - "
echo
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  isql_show_big_tables;;
                    2)  ;;
                    3)  ;;
                    b)  print_02;;
                    *) shortcuts;; esac; done
}

print_06_02(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Database structure consistency check functions. ${MAGENDA}https://wiki.scn.sap.com/wiki/display/SYBASE/Consistency+Checkers+and+Fixers${RESTORE}"
echo
echo "1  -  Database check [CHECKDB] ${MAGENDA}[Validates the integrity of a data and index pages for each table within a database]${RESTORE}"
echo "2  -  Storage check [CHECKSTORAGE] ${MAGENDA}[Checks against the database on disk] [To use this, create 'dbccdb' in menu section 2a]${RESTORE}"
echo "2a -  Creating 'dbccdb' as prerequisite for 'DBCC CHECKSTORAGE'${RESTORE}"
echo "3  -  Allocation check [CHECKALLOC] ${MAGENDA}[Detect allocation errors within a database]${RESTORE}"
echo "4  -  Table check [CHECKTABLE] ${MAGENDA}[Validates the integrity of a data and index pages for a single table]${RESTORE}"
echo "5  -  Table allocations check [TABLEALLOC] ${MAGENDA}[Validate and/or fix the integrity of a table's allocation]${RESTORE}"
echo "6  -  Index allocations check [INDEXALLOC] ${MAGENDA}[Validate and/or fix the integrity of an object's allocation for a specific indid]${RESTORE}"
echo "7  -  Text allocations check [TEXTALLOC] ${MAGENDA}[Validate and/or fix the integrity of a table's allocation for text and image columns]${RESTORE}"
echo "8  -  Catalog check [CHECKCATALOG] ${MAGENDA}[Check the consistency of the system tables for a database]${RESTORE}"
echo "9  -  Check global application map (GAM) ${MAGENDA}[Detect and correct invalid bit settings in SYSGAMS within a database]${RESTORE}"
echo "10 -  Check checkstorage results [DBCC CHECKVERIFY] ${MAGENDA}[Examines the results of the last CHECKSTORAGE and reclassifies each soft fault as hard, confirmed soft or insignificant]${RESTORE}"
echo "11 -  Database repair [DBCC REPAIR] ${MAGENDA}[Update or repair various information for a database, https://wiki.scn.sap.com/wiki/display/SYBASE/DBCC+dbrepair]${RESTORE}"
echo
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  dbcc_checkdb;;
                    2)  dbcc_checkstorage;;
                    2a) dbcc_checkstorage_createdb;;
                    3)  dbcc_checkalloc;;
                    4)  dbcc_checktable;;
                    5)  dbcc_tablealloc;;
                    6)  dbcc_indexalloc;;
                    7)  dbcc_textalloc;;
                    8)  dbcc_checkcatalog;;
                    9)  dbcc_gam;;
                    10) dbcc_checkverify;;
                    11) dbcc_dbrepair;;
                    b)  print_06;;
                    *) shortcuts;; esac; done
}

print_04_01(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Database backup functions"
echo
echo "1 - Dump a database to dump-file"
echo "2 - Recovery a database from dump-file"
echo "3 - "
echo "4 - "
echo
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  dump_db2file;;
                    2)  dump_file2db;;
                    3)  ;;
                    4)  ;;
                    b)  print_04;;
                    *) shortcuts;; esac; done
}




print_04_08(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Additional functions for backup and copy"
echo
echo "1 - Update of compression rates"
echo "2 - Preparation of RMAN backups"
echo "3 - Deletion of database disk backups"
echo "4 - Deletion of archivelog disk backups"
echo "5 - Controlling of BRARCHIVE run"
echo "6 - Initialization of BRBACKUP tape volumes"
echo "7 - Initialization of BRARCHIVE tape volumes"
echo
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  ;;
                    2)  ;;
                    3)  ;;
                    4)  ;;
                    5)  ;;
                    b)  print_04;;
                    *) shortcuts;; esac; done
}

print_07_01(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Update statistics functions" 
echo
echo "    ${BOLD}[Standart Update Statistics]${RESTORE}"
echo "1 - Update table statistics ${MAGENDA}(that are stored in systabstats table, such as rowcount, cluster ratios, and so on. Does not affect column statistics stored in sysstatistics)${RESTORE}"
echo "2 - Update multiple tables statistics ${MAGENDA}(the same action as the '1.' entry in the menu, but for multiple tables)${RESTORE}"
echo "3 - Update index statistics ${MAGENDA}(for all columns in an index)${RESTORE}"
echo "    ${BOLD}[Advanced Update Statistics]${RESTORE}"
echo "4 - Update statistics ${MAGENDA}(Updates information about the distribution of key values in specified indexes, for all columns in an index, table, or partition, and resets the data change counters for global nonclustered indexes)${RESTORE}"
echo "5 - Update all statistics ${MAGENDA}(including histograms on all columns, regardless of whether they are indexed. You can run 'update all statistics' on a single data partition)${RESTORE}"
echo "6 - Update all statistics ${MAGENDA}(the same action as the '5.' entry in the menu, but for multiple tables)${RESTORE}"
echo "    ${BOLD}[Full Update Statistics]${RESTORE}"
echo "7 - Update index statistics of all(!) tables ${MAGENDA}(It will be done with the script from SAP Note 1757691. It takes more much time!!!)${RESTORE}"
echo
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  isql_table_stats_update;;
                    2)  isql_table_stats_update_mass;;
                    3)  isql_idx_stats_update;;
                    4)  isq_stats_update;;
                    5)  isql_all_stats_update;;
                    6)  isql_all_stats_update_mass;;
                    7)  isql_idx_stats_update_mass;;
                    b)  print_07;;
                    *) shortcuts;; esac; done
}

print_07_03(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Statistics deletion functions"
echo
echo "1 - Delete statistics of multiple tables"
echo "2 - Delete statistics of a specific table, it's partitions or columns"
echo
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  isql_table_stats_del_mass;;
                    2)  isql_table_stats_del;;
                    b)  print_07;;
                    *) shortcuts;; esac; done
}


print_08_01(){
setpage="${FUNCNAME[0]}"
unset_temp_vars; top_info; menu_separator;
echo "Show profiles and logs"
echo
echo "1 - Sybase profile"
echo "2 - ASETools profile"
echo "3 - "
echo "4 - "
echo
echo
echo
echo
echo
shotcuts_text_short
menu_separator
while true; do read -p "Enter your choice: " answer
      case "$answer" in
                    1)  ;;
                    2)  ;;
                    3)  ;;
                    4)  ;;
                    5)  ;;
                    b)  print_08;;
                    *) shortcuts;; esac; done
}


###############################################   GENERAL CHECKS   ##########################################
if [[ "$1" == "nokey" ]]; then s1=nokey; 
        elif [ "$1" == "log_monitor" ]; then LOG_DIR="$2"; log_monitor; fi 

if [[ "$OSTYPE" != "linux" ]]; then echo "ERROR: the operation system type is not Linux. Other OS are not supported yet."; exit 1; fi 

if [[ "$USER" =~ "syb" ]]; then SYBASE_SID="${USER:3}"; 
                                SYBASE_SID=$(echo ${SYBASE_SID} | tr '[:lower:]' '[:upper:]');
                                sybase_user="$USER"  
                           elif [[ "$USER" =~ "root" ]]; then rooty=1; echo "${BOLD}${YELLOW}WARNING! You have started the script as a superuser. This mode should be used only for ASE server update/upgrade!${RESTORE}";
                                                                       echo "${BOLD}${RED}We strongly recommend to run it under: 'screen -S ASETOOLS'${RESTORE}"
                                                                       echo "For daily-tasks please run the script as syb<sid>."
                                                                       #echo "HINT: The script parameter 'nokey' prevents using aseuserstore-keys."    
                                                         else exit 1; fi
    
if [ "$rooty" == "1" ]; then while true; do echo
                                         read -p "Provide a ${GREEN}SID${RESTORE} of the ASE instance: " sybase_sid; 
                                         sybase_sid=$(echo ${sybase_sid} | tr '[:upper:]' '[:lower:]');
                                         SYBASE_SID=$(echo ${sybase_sid} | tr '[:lower:]' '[:upper:]');
                                         sybase_user="syb${sybase_sid}"
                                         SYBASE="/sybase/${SYBASE_SID}"
                                         adm_user="${sybase_sid}adm"
                                         if [ -z "$sybase_sid" ]; then continue; fi 
                                         if grep "$sybase_user" /etc/passwd > /dev/null; then SYBASE_ASE="$(su $sybase_user -c 'echo $SYBASE_ASE')"; break;
                                                                                         else echo "${RED}ERROR: The user $sybase_user is not presented on the server!${RESTORE}"; continue; fi; done
                         else if ! showserver &>/dev/null; then echo "${RED}ERROR: Start the script in correct user envinroment!${RESTORE}"; exit 1; fi; fi

run_file=${SYBASE}/${SYBASE_ASE}/install/RUN_${SYBASE_SID}
run_file_bkp=${SYBASE}/${SYBASE_ASE}/install/RUN_${SYBASE_SID}_BS
alert_log=${SYBASE}/${SYBASE_ASE}/install/${SYBASE_SID}.log
alert_log_bkp=${SYBASE}/${SYBASE_ASE}/install/${SYBASE_SID}_BS.log
jsagent_log=${SYBASE}/${SYBASE_ASE}/install/${SYBASE_SID}_JSAGENT.log
if [[ ! -e "$run_file" ]]; then echo -e "${RED}ERROR: The RUN-file not found at it's standard location: $run_file ${RESTORE}\n"; go=0; fi
if [[ ! -e "$run_file_bkp" ]]; then echo -e "${RED}ERROR: The RUN-BS-file not found at it's standard location: $run_file_bkp ${RESTORE}\n"; go=0; fi
if [[ ! -e "$alert_log" ]]; then echo -e "${RED}ERROR: The Alert-log-file not found at it's standard location: $alert_log ${RESTORE}\n"; go=0; fi
if [[ ! -e "$alert_log_bkp" ]]; then echo -e "${RED}ERROR: The Alert-BS-log-file not found at it's standard location: $alert_log_bkp ${RESTORE}\n"; go=0; fi
if [[ "$go" = "0" ]]; then echo "Please fix the problems with the files and start the script again!"; exit 1; fi

####################################################   MAIN   ###############################################
echo "${BOLD}ASETOOLS v.1.0 - $VERSION${RESTORE}"
echo
if [ "$rooty" != "1" ]; then session_name;
                             passwd_or_key;
                             print_info;
                             print_main;
                             exit 0;
                        else session_name;
                             passwd_or_key_root 
                             print_info;
                             print_main_root;
                             exit 0; fi
                        
